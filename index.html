<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>爻</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="style.css">
    <style id="fontStyle">
        /* 动态字体样式 */
    </style>
</head>
<body>
    <div class="header">
        <div class="api-status" id="apiStatus">
            <span class="api-status-dot"></span>
            <span class="api-status-text">检查中...</span>
        </div>
        <div class="header-center">
            <h1>爻</h1>
            <p>一念成仙，一念成魔</p>
        </div>
        <div class="time-display" id="timeDisplay" onclick="toggleTimeMenu()" style="display: none;">
            卯时 · 初春 · 第一日
        </div>
        <div class="header-buttons" id="headerButtons">
            <button class="header-btn" onclick="createNewCharacter()">新角色</button>
            <button class="header-btn" onclick="openSettings()">设置</button>
        </div>
    </div>

    <!-- 时间菜单浮层 -->
    <div class="time-menu" id="timeMenu" style="display: none;">
        <div class="time-menu-content">
            <div class="time-menu-actions">
                <span onclick="createNewCharacter()">新角色</span>
                <span onclick="loadGame()">读档</span>
                <span onclick="saveGame()">存档</span>
                <span onclick="openSettings()">设置</span>
            </div>
        </div>
    </div>

    <!-- 设置面板（全屏模态框） -->
    <div class="settings-modal-overlay" id="settingsModal">
        <div class="settings-modal">
            <button class="settings-close-btn" onclick="closeSettings()" title="关闭">×</button>
            <h2>游戏设置</h2>
            
            <div class="settings-content">
                <!-- API设置 -->
                <div class="settings-section">
                    <div class="settings-section-title" style="display: flex; justify-content: space-between; align-items: center;">
                        <span>API 设置</span>
                        <button type="button" class="settings-btn" style="padding: 6px 12px; font-size: 12px;" onclick="showApiHelp()" title="如何获取API Key">帮助</button>
                    </div>
                    
                    <!-- API提供商选择 -->
                    <label>选择 API 提供商</label>
                    <select id="apiProviderSelect" onchange="handleProviderChange()">
                        <option value="deepseek">DeepSeek</option>
                        <option value="openai">OpenAI</option>
                        <option value="gemini">Google Gemini</option>
                        <option value="claude">Claude</option>
                        <option value="grok">Grok</option>
                        <option value="mistral">Mistral</option>
                        <option value="qwen">Qwen</option>
                        <option value="llama">Llama</option>
                        <option value="other">其他模型</option>
                        <option value="custom">自定义</option>
                    </select>
                    
                    <!-- 自定义API配置 -->
                    <div id="customApiSection" style="display: none; margin-top: 15px; padding: 15px; background: #f9f8f6; border: 1px solid #e0dcd4; border-radius: 6px;">
                        <label style="font-size: 12px;">API名称</label>
                        <input type="text" id="customApiName" placeholder="自定义API名称" style="margin-bottom: 10px;">
                        <label style="font-size: 12px;">API地址</label>
                        <input type="text" id="customApiUrl" placeholder="https://api.example.com/v1/chat/completions" style="margin-bottom: 10px;">
                        <label style="font-size: 12px;">可用模型（用逗号分隔）</label>
                        <input type="text" id="customApiModels" placeholder="model-1, model-2">
                    </div>
                    
                    <!-- API Key管理 -->
                    <div style="margin-top: 20px;">
                        <label style="display: flex; justify-content: space-between; align-items: center;">
                            <span>API Key 管理</span>
                            <span class="hint" style="font-size: 11px;">支持5个Key，自动轮换</span>
                        </label>
                        <div id="apiKeysList" style="margin-top: 10px;">
                            <!-- 动态生成API Key输入框 -->
                        </div>
                    </div>
                    
                    <!-- 模型选择 -->
                    <div style="margin-top: 20px;">
                        <label>选择模型</label>
                        <select id="apiModelSelect">
                            <option value="">使用默认模型</option>
                        </select>
                    </div>
                    
                    <!-- 生成参数 -->
                    <div style="margin-top: 20px; display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                        <div>
                            <label style="display: flex; justify-content: space-between;">
                                <span>Temperature</span>
                                <span id="temperatureValue" class="hint" style="font-size: 11px;">0.7</span>
                            </label>
                            <input type="range" id="temperatureSlider" min="0.3" max="1.0" step="0.1" value="0.7" oninput="updateTemperatureDisplay(this.value)">
                            <p class="hint" style="font-size: 10px; margin-top: 5px;">较低值更稳定，较高值更有创意</p>
                        </div>
                        <div>
                            <label style="display: flex; justify-content: space-between;">
                                <span>Max Tokens</span>
                                <span id="maxTokensValue" class="hint" style="font-size: 11px;">1000</span>
                            </label>
                            <input type="range" id="maxTokensSlider" min="500" max="2000" step="100" value="1000" oninput="updateMaxTokensDisplay(this.value)">
                            <p class="hint" style="font-size: 10px; margin-top: 5px;">生成文本的最大长度</p>
                        </div>
                    </div>
                    
                    <!-- API状态显示 -->
                    <div id="apiStatusDisplay" style="margin-top: 15px; padding: 10px; background: #f5f3f0; border-radius: 4px; font-size: 12px;">
                        <!-- 动态显示API状态 -->
                    </div>
                </div>
                
                <!-- 存档管理 -->
                <div class="settings-section">
                    <div class="settings-section-title" style="display: flex; justify-content: space-between; align-items: center;">
                        <span>存档管理</span>
                        <div>
                            <span class="hint" style="font-size: 11px; margin-right: 10px;">最多10个存档位</span>
                            <button type="button" class="settings-btn" style="padding: 4px 10px; font-size: 11px;" onclick="showSaveHelp()" title="存档帮助">?</button>
                        </div>
                    </div>
                    
                    <!-- 存档位列表 -->
                    <div id="saveSlotsList" class="save-slots-list" style="max-height: 400px; overflow-y: auto;">
                        <!-- 动态生成存档位 -->
                    </div>
                    
                    <!-- 存档操作按钮 -->
                    <div class="save-slot-actions" style="margin-top: 20px; display: flex; gap: 12px;">
                        <button type="button" class="settings-btn" onclick="createNewSave()">新建存档</button>
                        <button type="button" class="settings-btn" onclick="importSaveFile()">导入存档</button>
                    </div>
                    
                    <!-- 导入文件输入 -->
                    <input type="file" id="saveFileInput" accept=".yao" style="display: none;" onchange="handleSaveFileImport(event)">
                </div>
                
                <!-- 字体设置 -->
                <div class="settings-section">
                    <div class="settings-section-title">字体设置</div>
                    <label>字体选择</label>
                    <select id="fontSelect" onchange="handleFontChange()">
                        <option value="default">默认字体（思源宋体）</option>
                        <option value="kaiti">楷体</option>
                        <option value="songti">宋体</option>
                        <option value="heiti">黑体</option>
                        <option value="custom">自定义字体</option>
                    </select>
                    
                    <!-- 自定义字体设置 -->
                    <div id="customFontSection" style="display: none; margin-top: 20px; padding: 20px; background: #f9f8f6; border: 1px solid #e0dcd4; border-radius: 6px;">
                        <label style="font-size: 12px; margin-bottom: 10px;">上传字体文件 (.ttf 或 .otf)</label>
                        <input type="file" id="fontFileInput" accept=".ttf,.otf,.woff,.woff2" style="display: none;">
                        <button type="button" class="settings-btn" onclick="document.getElementById('fontFileInput').click()" style="width: 100%; margin-bottom: 10px;">选择字体文件</button>
                        <p id="fontFileName" class="hint" style="margin-top: 5px; margin-bottom: 10px;">未选择文件</p>
                        <p class="hint" style="font-size: 11px; color: #8a8278;">提示：字体文件会保存在浏览器本地，建议文件大小不超过 20MB</p>
                    </div>
                    
                    <p class="hint" style="margin-top: 15px;">选择系统字体或上传你自己的字体文件</p>
                </div>
                
                <!-- 界面风格设置（占位） -->
                <div class="settings-section" style="opacity: 0.7;">
                    <div class="settings-section-title">界面风格</div>
                    <div style="padding: 30px; text-align: center; color: #8a8278; background: #f9f8f6; border-radius: 8px; border: 2px dashed #d0ccc5;">
                        <div style="font-size: 24px; margin-bottom: 10px;">[画]</div>
                        <div style="font-size: 14px; letter-spacing: 2px;">敬请期待</div>
                        <div style="font-size: 11px; margin-top: 8px; color: #a8a098;">更多界面主题风格即将推出</div>
                    </div>
                </div>
            </div>
            
            <div class="settings-actions">
                <button class="settings-btn" onclick="closeSettings()">取消</button>
                <button class="settings-btn primary" onclick="saveSettings()">保存设置</button>
            </div>
        </div>
    </div>

    <div class="container">
        <!-- 卷轴区域 - 包含剧情、选项、输入 -->
        <div class="scroll-container">
            <div class="scroll-content">
                <!-- 对话显示区域 -->
                <div class="chat-area" id="chatArea">
                    <div class="welcome-message" id="welcomeMessage">
                        <h2>欢迎来到修仙世界</h2>
                        <p id="welcomeText">加载中...</p>
                    </div>
                </div>

                <!-- 正在输入提示 -->
                <div class="typing-indicator" id="typingIndicator">
                    <span class="ink-loader"></span>
                    对方正在输入...
                </div>

                <!-- 可折叠选项面板 -->
                <div class="options-panel" id="optionsPanel">
                    <div class="options-toggle" onclick="toggleOptions()">
                        <span class="options-toggle-text">展开行动选项</span>
                        <span class="options-toggle-icon">▲</span>
                    </div>
                    <div class="options-content" id="optionsContent">
                        <div class="options-area" id="optionsArea">
                            <!-- 选项按钮会动态生成 -->
                        </div>
                    </div>
                </div>

                <!-- 输入区域 -->
                <div class="input-area">
                    <input
                        type="text"
                        class="input-box"
                        id="inputBox"
                        placeholder="书此以行……"
                        maxlength="100"
                    >
                    <button class="send-btn" id="sendBtn" onclick="sendMessage()" title="发送">
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div class="footer-decoration">
        修仙问道 · 初入仙途
    </div>

    <!-- 底部导航栏 -->
    <nav class="bottom-nav">
        <button class="nav-btn" onclick="openCharacterPanel()">角色</button>
        <button class="nav-btn" onclick="openSectPanel()">门派</button>
        <button class="nav-btn" onclick="openMap()">地图</button>
    </nav>

    <!-- 角色属性面板 -->
    <div class="character-panel-overlay" id="characterPanelOverlay" onclick="closeCharacterPanel(event)">
        <div class="character-panel" onclick="event.stopPropagation()">
            <div class="panel-header">
                <h2>角色属性</h2>
                <button class="close-btn" onclick="closeCharacterPanel()">&times;</button>
            </div>
            <div class="panel-content" id="characterPanelContent">
                <div class="loading-text">加载中...</div>
            </div>
        </div>
    </div>

    <!-- 门派列表面板 -->
    <div class="character-panel-overlay" id="sectPanelOverlay" onclick="closeSectPanel(event)">
        <div class="character-panel" onclick="event.stopPropagation()">
            <div class="panel-header">
                <h2>仙门列表</h2>
                <button class="close-btn" onclick="closeSectPanel()">&times;</button>
            </div>
            <div class="panel-content" id="sectPanelContent">
                <div class="loading-text">正在寻访仙门...</div>
            </div>
        </div>
    </div>

    <!-- 门派详情弹窗 -->
    <div class="character-panel-overlay" id="sectDetailOverlay" onclick="closeSectDetail(event)">
        <div class="character-panel" onclick="event.stopPropagation()">
            <div class="panel-header">
                <h2>门派详情</h2>
                <button class="close-btn" onclick="closeSectDetail()">&times;</button>
            </div>
            <div class="panel-content" id="sectDetailContent">
                <div class="loading-text">正在查探详情...</div>
            </div>
        </div>
    </div>

    <!-- 地图面板 -->
    <div class="character-panel-overlay" id="mapPanelOverlay" onclick="closeMap(event)">
        <div class="character-panel map-panel-container" onclick="event.stopPropagation()">
            <div class="panel-header map-panel-header">
                <h2>六界地图</h2>
                <div id="map-breadcrumb">
                    <span class="map-crumb active" data-level="world">六界</span>
                </div>
                <button class="close-btn" onclick="closeMap()">&times;</button>
            </div>
            <div class="panel-content map-panel-content">
                <!-- 主体 -->
                <div id="map-main">
                    <!-- 左侧地图面板 -->
                    <div id="map-panel">
                        <div id="map-loading" style="display: block; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #c9a96e; font-size: 14px;">加载中...</div>
                        <div id="map-layer-header" class="map-layer-title">
                            第一层 · <span>世界总览</span>　—　点击任意界进入
                        </div>
                        <div class="map-node-grid" id="map-node-grid"></div>
                    </div>

                    <!-- 详情面板 -->
                    <div id="map-detail-panel">
                        <div class="map-detail-title">选择一个地点</div>
                        <div class="map-detail-type">地图导航</div>
                        <hr class="map-detail-divider">
                        <div class="map-detail-section">
                            <label>提示</label>
                            <p>点击左侧节点查看详情，双击或点击「进入」按钮钻入下一层。</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 任务详情弹窗 -->
    <div class="character-panel-overlay" id="taskDetailOverlay" onclick="closeTaskDetail(event)">
        <div class="character-panel" onclick="event.stopPropagation()">
            <div class="panel-header">
                <h2>门派任务</h2>
                <button class="close-btn" onclick="closeTaskDetail()">&times;</button>
            </div>
            <div class="panel-content" id="taskDetailContent">
                <div class="loading-text">正在生成任务...</div>
            </div>
        </div>
    </div>

    <!-- 引入前端服务 -->
    <script src="./js/app.bundle.js"></script>
    <script>
        // 全局变量
        let currentOptions = [];
        let isInitialized = false;

        // 初始化应用
        async function initApp() {
            try {
                console.log('正在初始化应用...');
                await app.init();
                isInitialized = true;
                console.log('应用初始化成功');
                
                // 加载角色信息
                await loadCharacterInfo();
                
                // 更新API状态
                updateApiStatus();
            } catch (error) {
                console.error('应用初始化失败:', error);
                alert('应用初始化失败，请刷新页面重试');
            }
        }

        // 加载角色信息
        async function loadCharacterInfo() {
            try {
                const character = await app.getCurrentCharacter();
                console.log('从app获取的角色:', character);
                if (character) {
                    currentCharacter = character;
                    console.log('设置currentCharacter:', currentCharacter);
                    displayCharacterInfo();
                    showStartGameScreen();
                    // 更新时间显示
                    setTimeout(updateTimeDisplay, 100);
                } else {
                    showNoCharacterPrompt();
                }
            } catch (error) {
                console.error('加载角色信息失败:', error);
                showNoCharacterPrompt();
            }
        }

        // 获取DOM元素
        const chatArea = document.getElementById('chatArea');
        const inputBox = document.getElementById('inputBox');
        const sendBtn = document.getElementById('sendBtn');
        const optionsArea = document.getElementById('optionsArea');
        const typingIndicator = document.getElementById('typingIndicator');
        const settingsModal = document.getElementById('settingsModal');

        // 当前角色信息
        let currentCharacter = null;

        // 时间显示控制
        let timeMenuVisible = false;

        function toggleTimeMenu() {
            const timeMenu = document.getElementById('timeMenu');
            timeMenuVisible = !timeMenuVisible;
            timeMenu.style.display = timeMenuVisible ? 'block' : 'none';
        }

        function hideTimeMenu() {
            const timeMenu = document.getElementById('timeMenu');
            timeMenuVisible = false;
            timeMenu.style.display = 'none';
        }

        // 更新时间显示
        function updateTimeDisplay() {
            const timeDisplay = document.getElementById('timeDisplay');
            const headerButtons = document.getElementById('headerButtons');

            if (!timeDisplay) return;

            // 显示时间区域
            timeDisplay.style.display = 'block';
            if (headerButtons) {
                headerButtons.style.display = 'none';
            }

            // 如果有游戏进度，使用实际数据；否则使用默认值
            let hourName = '卯';
            let season = '春';
            let day = 1;

            if (app && app.gameStateService && app.gameStateService.gameProgress) {
                const progress = app.gameStateService.gameProgress;
                const hourNames = ['子', '丑', '寅', '卯', '辰', '巳', '午', '未', '申', '酉', '戌', '亥'];
                hourName = hourNames[progress.current_hour] || '卯';
                season = progress.season || '春';
                day = progress.total_days || 1;
            }

            // 更新显示文本
            const timeText = `${hourName}时 · ${season} · 第${day}日`;
            timeDisplay.textContent = timeText;
        }

        // 点击其他地方关闭时间菜单
        document.addEventListener('click', function(e) {
            const timeDisplay = document.getElementById('timeDisplay');
            const timeMenu = document.getElementById('timeMenu');
            if (timeMenuVisible && !timeDisplay.contains(e.target) && !timeMenu.contains(e.target)) {
                hideTimeMenu();
            }
        });

        // 更新API状态显示
        function updateApiStatus() {
            console.log('updateApiStatus被调用');
            
            const apiStatusEl = document.getElementById('apiStatus');
            if (!apiStatusEl) {
                console.error('找不到apiStatus元素');
                return;
            }
            
            const apiStatusText = apiStatusEl.querySelector('.api-status-text');
            if (!apiStatusText) {
                console.error('找不到api-status-text元素');
                return;
            }
            
            // 检查是否有API Key
            const hasKey = app.hasApiKey();
            console.log('API Key状态:', hasKey ? '已配置' : '未配置');
            
            if (hasKey) {
                apiStatusEl.className = 'api-status configured';
                apiStatusText.textContent = 'API 已配置';
                console.log('API状态已更新为: 已配置');
                
                // 更新欢迎界面为创建角色
                updateWelcomeMessage(true);
            } else {
                apiStatusEl.className = 'api-status';
                apiStatusText.textContent = 'API Key 未设置';
                console.log('API状态已更新为: 未设置');
                
                // 更新欢迎界面为配置API
                updateWelcomeMessage(false);
            }
        }
        
        // 更新欢迎界面
        function updateWelcomeMessage(hasApiKey) {
            const welcomeText = document.getElementById('welcomeText');
            const welcomeMessage = document.getElementById('welcomeMessage');
            
            if (!welcomeText || !welcomeMessage) return;
            
            // 检查是否已经有角色
            if (currentCharacter) return;
            
            if (hasApiKey) {
                // API已配置，显示创建角色界面
                welcomeMessage.innerHTML = `
                    <h2>初入仙途</h2>
                    <p>道友，你尚未创建角色<br>请先创建角色，开启你的修仙之旅</p>
                    <button class="create-character-btn" onclick="goToCreateCharacter()" style="margin-top: 20px; padding: 10px 30px; background: #8b7355; color: white; border: none; border-radius: 4px; cursor: pointer; font-family: 'Noto Serif SC', serif;">创建角色</button>
                `;
            } else {
                // API未配置，显示配置提示
                welcomeText.innerHTML = '点击右上角「设置」配置 API Key<br>开启你的修仙之旅';
            }
        }

        // 点击API状态指示器打开设置
        document.getElementById('apiStatus').addEventListener('click', function() {
            openSettings();
        });

        // 确保DOM完全加载后再执行状态检查
        function initApiStatus() {
            console.log('initApiStatus执行，DOM状态:', document.readyState);
            updateApiStatus();
        }
        
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initApiStatus);
        } else {
            initApiStatus();
        }
        
        // 页面完全加载后启动定时器
        window.addEventListener('load', function() {
            // 每5秒自动更新一次API状态
            setInterval(updateApiStatus, 5000);
        });

        // 字体配置
        const fontConfig = {
            'default': '"Noto Serif SC", "SimSun", "STSong", "宋体", serif',
            'kaiti': '"KaiTi", "楷体", "STKaiti", serif',
            'songti': '"SimSun", "STSong", "宋体", serif',
            'heiti': '"SimHei", "STHeiti", "黑体", sans-serif',
            'custom': null // 自定义字体
        };

        // 加载保存的字体设置
        let currentFont = localStorage.getItem('game_font') || 'default';
        let customFontFamily = localStorage.getItem('game_custom_font_family') || '';
        let customFontUrl = '';

        // 从IndexedDB加载自定义字体
        async function initCustomFont() {
            if (currentFont === 'custom' && customFontFamily) {
                try {
                    const fontData = await loadCustomFont();
                    if (fontData) {
                        customFontUrl = fontData.data;
                        customFontFamily = fontData.name;
                        applyFont('custom');
                    }
                } catch (error) {
                    console.error('加载自定义字体失败:', error);
                }
            }
        }

        // 应用字体
        function applyFont(fontName) {
            const styleEl = document.getElementById('fontStyle');
            
            if (fontName === 'custom' && customFontFamily && customFontUrl) {
                // 应用自定义字体
                styleEl.textContent = `
                    @font-face {
                        font-family: 'CustomFont';
                        src: url('${customFontUrl}') format('truetype');
                        font-weight: normal;
                        font-style: normal;
                    }
                    body, .input-box, .option-btn, .send-btn, 
                    .modal-btn, .font-select, .header-btn {
                        font-family: 'CustomFont', ${fontConfig['default']} !important;
                    }
                `;
            } else {
                // 应用系统字体
                const fontFamily = fontConfig[fontName] || fontConfig['default'];
                styleEl.textContent = `
                    body, .input-box, .option-btn, .send-btn, 
                    .modal-btn, .font-select, .header-btn {
                        font-family: ${fontFamily} !important;
                    }
                `;
            }
            document.body.setAttribute('data-font', fontName);
        }

        // 初始化字体
        applyFont(currentFont);
        initCustomFont(); // 异步加载自定义字体

        // 从URL获取character_id
        function getCharacterIdFromUrl() {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('character_id');
        }

        // 从sessionStorage获取角色信息
        function getCharacterFromStorage() {
            const saved = sessionStorage.getItem('currentCharacter');
            if (saved) {
                return JSON.parse(saved);
            }
            return null;
        }

        // 加载角色信息
        async function loadCharacter(characterId) {
            try {
                // 检查应用是否初始化
                if (!isInitialized) {
                    await initApp();
                }

                // 使用前端服务加载角色
                const character = await app.gameStateService.loadGame(characterId);
                if (character) {
                    currentCharacter = character;
                    
                    // 更新sessionStorage
                    sessionStorage.setItem('currentCharacter', JSON.stringify({
                        id: character.id,
                        name: character.name,
                        gender: character.gender,
                        appearance: character.appearance,
                        realm: character.realm,
                        spiritual_root_type: character.spiritual_root_type,
                        spiritual_root_elements: character.spiritual_root_elements,
                        special_constitution: character.special_constitution
                    }));
                    
                    // 显示角色信息
                    displayCharacterInfo();
                    return true;
                } else {
                    console.error('加载角色失败');
                    return false;
                }
            } catch (error) {
                console.error('加载角色失败:', error);
                return false;
            }
        }

        // 显示无角色提示
        function showNoCharacterPrompt() {
            // 直接显示创建角色界面（因为能进入此函数说明应用已初始化）
            const chatAreaEl = document.getElementById('chatArea');
            if (chatAreaEl) {
                chatAreaEl.innerHTML = `
                    <div class="create-character-prompt">
                        <h2>初入仙途</h2>
                        <p>
                            道友，你尚未创建角色<br>
                            请先创建角色，开启你的修仙之旅
                        </p>
                        <button class="create-character-btn" onclick="goToCreateCharacter()">
                            创建角色
                        </button>
                    </div>
                `;
            }
            
            // 隐藏输入区域和选项面板
            const inputArea = document.querySelector('.input-area');
            const optionsPanel = document.getElementById('optionsPanel');
            if (inputArea) inputArea.style.display = 'none';
            if (optionsPanel) optionsPanel.style.display = 'none';
        }

        // 跳转到创建角色页面（打开模态框）
        function goToCreateCharacter() {
            openCharacterCreation();
        }

        // 创建新角色
        function createNewCharacter() {
            if (confirm('确定要创建新角色吗？当前角色进度将保留。')) {
                // 清除当前角色缓存
                sessionStorage.removeItem('currentCharacter');
                localStorage.removeItem('currentCharacter');
                // 打开角色创建模态框
                openCharacterCreation();
            }
        }

        // 显示开始游戏界面
        function showStartGameScreen() {
            const chatArea = document.getElementById('chatArea');
            
            if (!currentCharacter) return;
            
            console.log('显示角色信息:', currentCharacter);
            console.log('灵根类型:', currentCharacter.spiritual_root_type);
            console.log('灵根属性:', currentCharacter.spiritual_root_elements);
            
            chatArea.innerHTML = `
                <div class="start-game-screen">
                    <h2>角色已就绪</h2>
                    <div class="character-summary">
                        <div class="summary-item">
                            <span class="summary-label">姓名</span>
                            <span class="summary-value">${currentCharacter.name}</span>
                        </div>
                        <div class="summary-item">
                            <span class="summary-label">战力</span>
                            <span class="summary-value">${currentCharacter.combat_power || 100}</span>
                        </div>
                        <div class="summary-item">
                            <span class="summary-label">灵根</span>
                            <span class="summary-value">${
                                currentCharacter.spiritual_root_type && currentCharacter.spiritual_root_elements 
                                    ? `${currentCharacter.spiritual_root_type}(${currentCharacter.spiritual_root_elements})`
                                    : currentCharacter.spiritualRoot || '未设定'
                            }</span>
                        </div>
                        ${currentCharacter.special_constitution ? `
                        <div class="summary-item">
                            <span class="summary-label">体质</span>
                            <span class="summary-value">${currentCharacter.special_constitution}</span>
                        </div>
                        ` : ''}
                    </div>
                    <button class="start-game-btn" onclick="startGame()">开始游戏</button>
                </div>
            `;
            
            // 隐藏输入区域和选项面板
            document.querySelector('.input-area').style.display = 'none';
            document.getElementById('optionsPanel').style.display = 'none';
        }

        // 开始游戏
        function startGame() {
            // 显示输入区域和选项面板
            document.querySelector('.input-area').style.display = 'flex';
            document.getElementById('optionsPanel').style.display = 'block';
            
            // 清空对话区域
            chatArea.innerHTML = '';
            
            // 发送开始消息
            if (app && app.hasApiKey && app.hasApiKey()) {
                sendToServer('开始');
            } else {
                // 没有API Key，显示提示
                chatArea.innerHTML = `
                    <div class="welcome-message">
                        <h2>欢迎来到修仙世界</h2>
                        <p>请点击右上角「设置」配置 DeepSeek API Key<br>开启你的修仙之旅</p>
                    </div>
                `;
            }
        }

        // 显示角色信息
        function displayCharacterInfo() {
            if (!currentCharacter) return;
            
            // 在标题区域显示角色名和战力
            const charInfo = document.getElementById('characterInfo');
            if (charInfo) {
                charInfo.innerHTML = `
                    <div class="char-name">${currentCharacter.name}</div>
                    <div class="char-realm">战力：${currentCharacter.combat_power || 100}</div>
                `;
            }
            
            // 在欢迎消息中显示角色信息
            const chatAreaEl = document.getElementById('chatArea');
            if (chatAreaEl) {
                const welcomeMsg = chatAreaEl.querySelector('.welcome-message');
                if (welcomeMsg) {
                    welcomeMsg.innerHTML = `
                        <h2>欢迎回来，${currentCharacter.name}</h2>
                        <p>
                            战力：${currentCharacter.combat_power || 100}<br>
                            灵根：${
                                currentCharacter.spiritual_root_type && currentCharacter.spiritual_root_elements 
                                    ? `${currentCharacter.spiritual_root_type}(${currentCharacter.spiritual_root_elements})`
                                    : currentCharacter.spiritualRoot || '未设定'
                            }<br>
                            ${currentCharacter.special_constitution ? '体质：' + currentCharacter.special_constitution + '<br>' : ''}
                            <br>
                            你的修仙之旅即将开始...
                        </p>
                    `;
                }
            }
        }

        // 获取用户的角色列表
        async function getUserCharacters() {
            try {
                // 检查应用是否初始化
                if (!isInitialized) {
                    await initApp();
                }

                // 使用前端服务获取角色列表
                const characters = await app.getAllCharacters();
                return characters || [];
            } catch (error) {
                console.error('获取角色列表失败:', error);
                return [];
            }
        }

        // 页面加载完成后
        window.onload = async function() {
            try {
                // 初始化应用（initApp中会调用loadCharacterInfo，根据是否有角色显示不同界面）
                await initApp();
                
                // 注意：不要在这里调用showStartGameScreen()
                // 因为initApp -> loadCharacterInfo 已经会根据是否有角色显示正确的界面
            } catch (error) {
                console.error('页面加载失败:', error);
                // 显示错误提示
                const chatAreaEl = document.getElementById('chatArea');
                if (chatAreaEl) {
                    chatAreaEl.innerHTML = `
                        <div class="welcome-message">
                            <h2>应用加载失败</h2>
                            <p>请刷新页面重试，如果问题持续存在，请检查浏览器控制台获取详细错误信息</p>
                        </div>
                    `;
                }
            }
        };

        // 打开设置弹窗
        function openSettings() {
            document.getElementById('fontSelect').value = currentFont;
            
            // 显示/隐藏自定义字体区域
            const customSection = document.getElementById('customFontSection');
            const fontFileName = document.getElementById('fontFileName');
            if (currentFont === 'custom') {
                customSection.style.display = 'block';
                fontFileName.textContent = customFontFamily || '未选择文件';
            } else {
                customSection.style.display = 'none';
            }
            
            // 加载API配置
            loadApiSettings();
            
            // 渲染存档位
            renderSaveSlots();
            
            settingsModal.classList.add('show');
        }

        // 关闭设置弹窗
        function closeSettings() {
            settingsModal.classList.remove('show');
        }

        // ==================== API设置管理 ====================
        
        let currentApiConfig = null;
        
        // 加载API设置
        function loadApiSettings() {
            console.log('加载API设置...');
            const config = app.getApiConfig();
            
            // 深拷贝配置，避免直接修改app的配置
            console.log('深拷贝前config.keys:', config.keys.filter(k => k.key).length);
            currentApiConfig = {
                provider: config.provider,
                model: config.model,
                keys: JSON.parse(JSON.stringify(config.keys)), // 深拷贝keys数组
                temperature: config.temperature,
                maxTokens: config.maxTokens,
                customProvider: config.customProvider ? JSON.parse(JSON.stringify(config.customProvider)) : null,
                providers: config.providers
            };
            console.log('深拷贝后currentApiConfig.keys:', currentApiConfig.keys.filter(k => k.key).length);
            
            console.log('获取到的API配置provider:', currentApiConfig.provider);
            console.log('获取到的keys总数:', currentApiConfig.keys.length);
            console.log('有值的keys:', currentApiConfig.keys.filter(k => k.key).length);
            console.log('当前provider的keys:', currentApiConfig.keys.filter(k => k.provider === currentApiConfig.provider && k.key).map(k => ({id: k.id, name: k.name, keyLength: k.key.length})));
            
            // 设置提供商
            const providerSelect = document.getElementById('apiProviderSelect');
            providerSelect.value = currentApiConfig.provider;
            
            // 渲染API Key列表
            renderApiKeysList();
            
            // 更新模型列表
            updateModelSelect();
            
            // 恢复选中的模型
            if (currentApiConfig.model) {
                document.getElementById('apiModelSelect').value = currentApiConfig.model;
            }
            
            // 设置参数
            document.getElementById('temperatureSlider').value = currentApiConfig.temperature;
            document.getElementById('temperatureValue').textContent = currentApiConfig.temperature;
            document.getElementById('maxTokensSlider').value = currentApiConfig.maxTokens;
            document.getElementById('maxTokensValue').textContent = currentApiConfig.maxTokens;
            
            // 显示自定义API配置
            if (currentApiConfig.provider === 'custom') {
                document.getElementById('customApiSection').style.display = 'block';
                document.getElementById('customApiName').value = currentApiConfig.customProvider.name || '';
                document.getElementById('customApiUrl').value = currentApiConfig.customProvider.apiUrl || '';
                document.getElementById('customApiModels').value = (currentApiConfig.customProvider.models || []).join(', ');
            } else {
                document.getElementById('customApiSection').style.display = 'none';
            }
            
            // 更新API状态显示
            updateApiStatusDisplay();
            console.log('API设置加载完成');
        }
        
        // 渲染API Key列表
        function renderApiKeysList() {
            const container = document.getElementById('apiKeysList');
            const provider = currentApiConfig.provider;
            console.log('renderApiKeysList被调用，provider:', provider);
            
            // 获取当前provider的5个key，如果不存在则创建
            let keys = [];
            for (let i = 1; i <= 5; i++) {
                let key = currentApiConfig.keys.find(k => k.id === i && k.provider === provider);
                if (!key) {
                    // 如果找不到，创建一个新的key
                    key = { id: i, name: i === 1 ? '主Key' : `备用Key${i-1}`, key: '', provider: provider, model: '' };
                    currentApiConfig.keys.push(key);
                    console.log(`创建新key: provider=${provider}, id=${i}`);
                }
                keys.push(key);
            }
            console.log(`渲染${keys.length}个keys，有值的:`, keys.filter(k => k.key).length);
            
            let html = '';
            keys.forEach((key, index) => {
                const isMain = index === 0;
                const keyName = key.name || (isMain ? '主Key' : `备用Key${index}`);
                html += `
                    <div style="display: flex; gap: 10px; margin-bottom: 10px; align-items: center;">
                        <input type="text" 
                               id="apiKeyName_${provider}_${key.id}" 
                               value="${keyName}" 
                               placeholder="Key名称"
                               style="width: 100px; padding: 8px; font-size: 12px;"
                               onchange="updateApiKeyName(${key.id}, this.value)">
                        <input type="password" 
                               id="apiKeyValue_${provider}_${key.id}" 
                               value="${key.key || ''}" 
                               placeholder="${isMain ? '主 API Key' : '备用 API Key ' + index}"
                               style="flex: 1; padding: 8px; font-size: 12px;"
                               onchange="updateApiKeyValue(${key.id}, this.value)">
                        <span id="apiKeyStatus_${provider}_${key.id}" style="font-size: 11px; min-width: 50px; text-align: center;">
                            ${key.key ? '[已填]' : '[空]'}
                        </span>
                    </div>
                `;
            });
            
            container.innerHTML = html;
        }
        
        // 处理提供商变更
        function handleProviderChange() {
            const provider = document.getElementById('apiProviderSelect').value;
            console.log('切换API提供商到:', provider);
            
            // 更新当前配置（还未保存到app）
            currentApiConfig.provider = provider;
            
            // 显示/隐藏自定义API配置
            document.getElementById('customApiSection').style.display = provider === 'custom' ? 'block' : 'none';
            
            // 重新渲染Key列表
            renderApiKeysList();
            
            // 更新模型列表
            updateModelSelect();
            
            // 更新API状态显示
            updateApiStatusDisplay();
            
            console.log('提供商切换完成，当前keys:', currentApiConfig.keys.filter(k => k.provider === provider && k.key));
        }
        
        // 更新模型选择列表
        function updateModelSelect() {
            const provider = document.getElementById('apiProviderSelect').value;
            const modelSelect = document.getElementById('apiModelSelect');
            const providerInfo = currentApiConfig.providers[provider];
            
            let html = '<option value="">使用默认模型</option>';
            if (providerInfo && providerInfo.models) {
                providerInfo.models.forEach(model => {
                    html += `<option value="${model}">${model}</option>`;
                });
            }
            modelSelect.innerHTML = html;
        }
        
        // 更新API Key名称
        function updateApiKeyName(keyId, name) {
            const provider = currentApiConfig.provider;
            const key = currentApiConfig.keys.find(k => k.id === keyId && k.provider === provider);
            if (key) {
                key.name = name.trim();
                console.log(`API Key ${keyId} 名称已更新为: ${name.trim()}`);
            }
        }
        
        // 更新API Key值
        function updateApiKeyValue(keyId, value) {
            const provider = currentApiConfig.provider;
            console.log(`updateApiKeyValue被调用: provider=${provider}, keyId=${keyId}, value长度=${value.trim().length}`);
            const key = currentApiConfig.keys.find(k => k.id === keyId && k.provider === provider);
            if (key) {
                key.key = value.trim();
                // 更新状态显示
                const statusEl = document.getElementById(`apiKeyStatus_${provider}_${keyId}`);
                if (statusEl) {
                    statusEl.textContent = value.trim() ? '[已填]' : '[空]';
                }
                console.log(`API Key ${keyId} 已更新，当前provider的keys数量:`, currentApiConfig.keys.filter(k => k.provider === provider && k.key).length);
                // 实时更新API状态显示
                updateApiStatusDisplay();
            } else {
                console.error(`找不到Key: provider=${provider}, id=${keyId}`);
                console.log('可用的keys:', currentApiConfig.keys.filter(k => k.provider === provider));
            }
        }
        
        // 更新温度显示
        function updateTemperatureDisplay(value) {
            document.getElementById('temperatureValue').textContent = value;
            const slider = document.getElementById('temperatureSlider');
            const percent = ((value - 0.3) / (1.0 - 0.3)) * 100;
            slider.style.setProperty('--value', percent + '%');
        }
        
        // 更新Max Tokens显示
        function updateMaxTokensDisplay(value) {
            document.getElementById('maxTokensValue').textContent = value;
            const slider = document.getElementById('maxTokensSlider');
            const percent = ((value - 500) / (2000 - 500)) * 100;
            slider.style.setProperty('--value', percent + '%');
        }
        
        // 更新API状态显示
        function updateApiStatusDisplay() {
            const statusDiv = document.getElementById('apiStatusDisplay');
            const provider = currentApiConfig.provider;
            
            // 使用currentApiConfig中的keys（未保存的更改）
            const activeKeys = currentApiConfig.keys.filter(k => k.key && k.provider === provider);
            
            console.log('更新API状态显示:', { provider, activeKeys: activeKeys.length });
            
            if (activeKeys.length === 0) {
                statusDiv.innerHTML = `<span style="color: #c44;">[警告] 未配置API Key</span>`;
            } else {
                const keyNames = activeKeys.map(k => k.name || `Key${k.id}`).join(', ');
                statusDiv.innerHTML = `<span style="color: #4a6;">[可用] ${activeKeys.length}个Key可用</span><br><span style="font-size: 10px; color: #8a8278;">${keyNames}</span>`;
            }
        }
        
        // 显示API帮助
        function showApiHelp() {
            const helpContent = `
                <div style="max-width: 600px; max-height: 70vh; overflow-y: auto;">
                    <h3 style="margin-bottom: 20px; color: #3a352e; border-bottom: 2px solid #d0ccc5; padding-bottom: 10px;">API 获取指南</h3>
                    
                    <div style="margin-bottom: 20px; padding: 15px; background: #f9f8f6; border-radius: 8px;">
                        <h4 style="color: #5a5248; margin-bottom: 10px;">[1] DeepSeek</h4>
                        <a href="https://platform.deepseek.com" target="_blank" style="color: #4a6; text-decoration: none; border-bottom: 1px solid #4a6;">https://platform.deepseek.com</a>
                        <p style="margin-top: 8px; color: #8a8278; font-size: 12px;">模型：deepseek-chat, deepseek-v3, deepseek-r1</p>
                    </div>
                    
                    <div style="margin-bottom: 20px; padding: 15px; background: #f9f8f6; border-radius: 8px;">
                        <h4 style="color: #5a5248; margin-bottom: 10px;">[2] OpenAI</h4>
                        <a href="https://platform.openai.com" target="_blank" style="color: #4a6; text-decoration: none; border-bottom: 1px solid #4a6;">https://platform.openai.com</a>
                        <p style="margin-top: 8px; color: #8a8278; font-size: 12px;">模型：gpt-4o, gpt-4-turbo, gpt-3.5-turbo</p>
                    </div>
                    
                    <div style="margin-bottom: 20px; padding: 15px; background: #f9f8f6; border-radius: 8px;">
                        <h4 style="color: #5a5248; margin-bottom: 10px;">[3] Google Gemini</h4>
                        <a href="https://makersuite.google.com/app/apikey" target="_blank" style="color: #4a6; text-decoration: none; border-bottom: 1px solid #4a6;">https://makersuite.google.com/app/apikey</a>
                        <p style="margin-top: 8px; color: #8a8278; font-size: 12px;">模型：gemini-2.5-pro, gemini-2.5-flash</p>
                    </div>
                    
                    <div style="margin-bottom: 20px; padding: 15px; background: #f9f8f6; border-radius: 8px;">
                        <h4 style="color: #5a5248; margin-bottom: 10px;">[4] Claude</h4>
                        <a href="https://console.anthropic.com" target="_blank" style="color: #4a6; text-decoration: none; border-bottom: 1px solid #4a6;">https://console.anthropic.com</a>
                        <p style="margin-top: 8px; color: #8a8278; font-size: 12px;">模型：claude-3.5-sonnet, claude-3-opus</p>
                    </div>
                    
                    <div style="margin-bottom: 20px; padding: 15px; background: #f9f8f6; border-radius: 8px;">
                        <h4 style="color: #5a5248; margin-bottom: 10px;">[5] Grok</h4>
                        <a href="https://x.ai" target="_blank" style="color: #4a6; text-decoration: none; border-bottom: 1px solid #4a6;">https://x.ai</a>
                        <p style="margin-top: 8px; color: #8a8278; font-size: 12px;">模型：grok-3, grok-4, grok-4.1</p>
                    </div>
                    
                    <div style="margin-bottom: 20px; padding: 15px; background: #f9f8f6; border-radius: 8px;">
                        <h4 style="color: #5a5248; margin-bottom: 10px;">[6] Mistral</h4>
                        <a href="https://console.mistral.ai" target="_blank" style="color: #4a6; text-decoration: none; border-bottom: 1px solid #4a6;">https://console.mistral.ai</a>
                        <p style="margin-top: 8px; color: #8a8278; font-size: 12px;">模型：mistral-large, mistral-medium</p>
                    </div>
                    
                    <div style="margin-bottom: 20px; padding: 15px; background: #f9f8f6; border-radius: 8px;">
                        <h4 style="color: #5a5248; margin-bottom: 10px;">[7] Qwen (通义千问)</h4>
                        <a href="https://dashscope.aliyun.com" target="_blank" style="color: #4a6; text-decoration: none; border-bottom: 1px solid #4a6;">https://dashscope.aliyun.com</a>
                        <p style="margin-top: 8px; color: #8a8278; font-size: 12px;">模型：qwen-235b-a22b, qwq-32b</p>
                    </div>
                    
                    <div style="margin-bottom: 20px; padding: 15px; background: #f9f8f6; border-radius: 8px;">
                        <h4 style="color: #5a5248; margin-bottom: 10px;">[8] Llama</h4>
                        <a href="https://llama.meta.com" target="_blank" style="color: #4a6; text-decoration: none; border-bottom: 1px solid #4a6;">https://llama.meta.com</a>
                        <p style="margin-top: 8px; color: #8a8278; font-size: 12px;">模型：llama-4-maverick</p>
                    </div>
                    
                    <div style="padding: 15px; background: #f9f8f6; border-radius: 8px;">
                        <h4 style="color: #5a5248; margin-bottom: 10px;">[9] 自定义</h4>
                        <p style="color: #8a8278; font-size: 12px;">支持任何OpenAI兼容格式的API</p>
                    </div>
                </div>
            `;
            
            // 创建自定义弹窗
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 9999;
            `;
            
            modal.innerHTML = `
                <div style="
                    background: #f5f3f0;
                    border: 1px solid #d0ccc5;
                    border-radius: 12px;
                    padding: 30px;
                    max-width: 90vw;
                    max-height: 90vh;
                    overflow: hidden;
                    box-shadow: 0 10px 40px rgba(0,0,0,0.2);
                ">
                    ${helpContent}
                    <div style="text-align: center; margin-top: 20px;">
                        <button onclick="this.closest('.modal-overlay').remove()" style="
                            padding: 10px 30px;
                            background: #5a5248;
                            color: #f5f3f0;
                            border: none;
                            border-radius: 6px;
                            cursor: pointer;
                            font-size: 14px;
                        ">关闭</button>
                    </div>
                </div>
            `;
            
            modal.className = 'modal-overlay';
            modal.addEventListener('click', function(e) {
                if (e.target === modal) modal.remove();
            });
            
            document.body.appendChild(modal);
        }

        // 显示存档帮助
        function showSaveHelp() {
            const helpContent = `
                <div style="max-width: 500px;">
                    <h3 style="margin-bottom: 20px; color: #3a352e; border-bottom: 2px solid #d0ccc5; padding-bottom: 10px;">存档功能说明</h3>
                    
                    <div style="margin-bottom: 20px; padding: 15px; background: #f9f8f6; border-radius: 8px;">
                        <h4 style="color: #5a5248; margin-bottom: 10px;">[保存] 新建存档</h4>
                        <p style="color: #6a6258; font-size: 13px; line-height: 1.6;">
                            将当前游戏进度保存到一个空的存档位。系统会自动寻找第一个空位进行保存。<br>
                            每个存档包含：角色信息、当前位置、游戏天数、对话历史等。
                        </p>
                    </div>
                    
                    <div style="margin-bottom: 20px; padding: 15px; background: #f9f8f6; border-radius: 8px;">
                        <h4 style="color: #5a5248; margin-bottom: 10px;">[导入] 导入存档</h4>
                        <p style="color: #6a6258; font-size: 13px; line-height: 1.6;">
                            从本地导入一个 .yao 格式的存档文件。可以导入自己之前导出的存档，或从其他设备/玩家处获得的存档文件。
                        </p>
                    </div>
                    
                    <div style="margin-bottom: 20px; padding: 15px; background: #f9f8f6; border-radius: 8px;">
                        <h4 style="color: #5a5248; margin-bottom: 10px;">[导出] 导出存档</h4>
                        <p style="color: #6a6258; font-size: 13px; line-height: 1.6;">
                            将存档导出为 .yao 文件，可以备份到本地或分享给其他玩家。<br>
                            文件名格式：角色名_日期.yao
                        </p>
                    </div>
                    
                    <div style="padding: 15px; background: #f9f8f6; border-radius: 8px;">
                        <h4 style="color: #5a5248; margin-bottom: 10px;">[备注] 存档备注</h4>
                        <p style="color: #6a6258; font-size: 13px; line-height: 1.6;">
                            点击存档下方的备注文字可以添加或修改备注，方便区分不同的存档。
                        </p>
                    </div>
                </div>
            `;
            
            // 创建自定义弹窗
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 9999;
            `;
            
            modal.innerHTML = `
                <div style="
                    background: #f5f3f0;
                    border: 1px solid #d0ccc5;
                    border-radius: 12px;
                    padding: 30px;
                    max-width: 90vw;
                    max-height: 90vh;
                    overflow: hidden;
                    box-shadow: 0 10px 40px rgba(0,0,0,0.2);
                ">
                    ${helpContent}
                    <div style="text-align: center; margin-top: 20px;">
                        <button onclick="this.closest('.modal-overlay').remove()" style="
                            padding: 10px 30px;
                            background: #5a5248;
                            color: #f5f3f0;
                            border: none;
                            border-radius: 6px;
                            cursor: pointer;
                            font-size: 14px;
                        ">关闭</button>
                    </div>
                </div>
            `;
            
            modal.className = 'modal-overlay';
            modal.addEventListener('click', function(e) {
                if (e.target === modal) modal.remove();
            });
            
            document.body.appendChild(modal);
        }

        // 字体选择变化处理
        function handleFontChange() {
            const fontSelect = document.getElementById('fontSelect');
            const customSection = document.getElementById('customFontSection');
            if (fontSelect.value === 'custom') {
                customSection.style.display = 'block';
            } else {
                customSection.style.display = 'none';
            }
        }
        
        // 绑定字体选择事件
        document.getElementById('fontSelect').addEventListener('change', handleFontChange);

        // 字体文件选择
        document.getElementById('fontFileInput').addEventListener('change', async function(e) {
            const file = e.target.files[0];
            if (file) {
                document.getElementById('fontFileName').textContent = file.name;
                
                // 检查文件大小（限制为20MB）
                if (file.size > 20 * 1024 * 1024) {
                    alert('字体文件过大，请选择小于20MB的文件');
                    return;
                }
                
                // 读取文件为 Data URL
                const reader = new FileReader();
                reader.onload = async function(event) {
                    customFontUrl = event.target.result;
                    customFontFamily = file.name;
                    
                    // 保存到 IndexedDB（避免localStorage 5MB限制）
                    try {
                        await saveCustomFont(customFontFamily, customFontUrl);
                        // 只保存字体名称到localStorage
                        localStorage.setItem('game_custom_font_family', customFontFamily);
                    } catch (error) {
                        console.error('保存字体失败:', error);
                        alert('字体保存失败，请重试');
                    }
                };
                reader.readAsDataURL(file);
            }
        });
        
        // 保存自定义字体到 IndexedDB
        async function saveCustomFont(fontName, fontData) {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('xiuxian_game', 3);
                
                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    const db = request.result;
                    
                    // 检查 store 是否存在
                    if (!db.objectStoreNames.contains('custom_fonts')) {
                        // 需要升级数据库
                        db.close();
                        const upgradeRequest = indexedDB.open('xiuxian_game', 4);
                        
                        upgradeRequest.onupgradeneeded = (event) => {
                            const upgradeDb = event.target.result;
                            if (!upgradeDb.objectStoreNames.contains('custom_fonts')) {
                                upgradeDb.createObjectStore('custom_fonts', { keyPath: 'id' });
                            }
                        };
                        
                        upgradeRequest.onsuccess = () => {
                            const newDb = upgradeRequest.result;
                            const transaction = newDb.transaction(['custom_fonts'], 'readwrite');
                            const store = transaction.objectStore('custom_fonts');
                            
                            store.put({
                                id: 'custom_font',
                                name: fontName,
                                data: fontData,
                                timestamp: Date.now()
                            });
                            
                            transaction.oncomplete = () => {
                                newDb.close();
                                resolve();
                            };
                            transaction.onerror = () => reject(transaction.error);
                        };
                        
                        upgradeRequest.onerror = () => reject(upgradeRequest.error);
                        return;
                    }
                    
                    const transaction = db.transaction(['custom_fonts'], 'readwrite');
                    const store = transaction.objectStore('custom_fonts');
                    
                    store.put({
                        id: 'custom_font',
                        name: fontName,
                        data: fontData,
                        timestamp: Date.now()
                    });
                    
                    transaction.oncomplete = () => resolve();
                    transaction.onerror = () => reject(transaction.error);
                };
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains('custom_fonts')) {
                        db.createObjectStore('custom_fonts', { keyPath: 'id' });
                    }
                };
            });
        }
        
        // 从 IndexedDB 加载自定义字体
        async function loadCustomFont() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('xiuxian_game', 3);
                
                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    const db = request.result;
                    
                    // 检查是否存在custom_fonts表
                    if (!db.objectStoreNames.contains('custom_fonts')) {
                        resolve(null);
                        return;
                    }
                    
                    const transaction = db.transaction(['custom_fonts'], 'readonly');
                    const store = transaction.objectStore('custom_fonts');
                    const getRequest = store.get('custom_font');
                    
                    getRequest.onsuccess = () => {
                        if (getRequest.result) {
                            resolve(getRequest.result);
                        } else {
                            resolve(null);
                        }
                    };
                    getRequest.onerror = () => reject(getRequest.error);
                };
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains('custom_fonts')) {
                        db.createObjectStore('custom_fonts', { keyPath: 'id' });
                    }
                };
            });
        }

        // 保存设置
        function saveSettings() {
            console.log('保存设置...');
            
            // 保存API配置
            const provider = document.getElementById('apiProviderSelect').value;
            const temperature = parseFloat(document.getElementById('temperatureSlider').value);
            const maxTokens = parseInt(document.getElementById('maxTokensSlider').value);
            const selectedModel = document.getElementById('apiModelSelect').value;
            
            console.log('保存配置:', { provider, temperature, maxTokens, selectedModel });
            console.log('保存前keys数量:', currentApiConfig.keys.filter(k => k.key).length);
            console.log('当前provider的keys:', currentApiConfig.keys.filter(k => k.provider === provider && k.key));
            
            // 更新所有Key的provider和model（只更新当前提供商的key）
            currentApiConfig.keys.forEach(key => {
                if (key.provider === provider && key.key) {
                    if (selectedModel) {
                        key.model = selectedModel;
                    }
                }
            });
            
            // 自定义API配置
            let customProvider = null;
            if (provider === 'custom') {
                customProvider = {
                    name: document.getElementById('customApiName').value,
                    apiUrl: document.getElementById('customApiUrl').value,
                    models: document.getElementById('customApiModels').value.split(',').map(s => s.trim()).filter(s => s)
                };
            }
            
            // 更新到应用
            console.log('调用app.updateApiConfig，传递的keys数量:', currentApiConfig.keys.filter(k => k.key).length);
            app.updateApiConfig({
                provider: provider,
                model: selectedModel,
                keys: currentApiConfig.keys,
                temperature: temperature,
                maxTokens: maxTokens,
                customProvider: customProvider
            });
            
            console.log('配置已保存到app，当前provider:', app.currentProvider);
            
            // 更新API状态显示（延迟一点确保保存完成）
            setTimeout(() => {
                console.log('延迟后调用updateApiStatus');
                updateApiStatus();
            }, 100);
            
            // 保存字体设置
            const selectedFont = document.getElementById('fontSelect').value;
            currentFont = selectedFont;
            localStorage.setItem('game_font', selectedFont);
            applyFont(selectedFont);
            
            closeSettings();
        }

        // 点击弹窗外部关闭
        settingsModal.addEventListener('click', function(e) {
            if (e.target === settingsModal) {
                closeSettings();
            }
        });

        // 监听回车键
        inputBox.addEventListener('keypress', function(e) {
            if (e.key === 'Enter' && !inputBox.disabled) {
                sendMessage();
            }
        });

        // 发送消息
        function sendMessage() {
            const message = inputBox.value.trim();
            if (!message) return;

            addMessage(message, 'user');
            inputBox.value = '';
            sendToServer(message);
        }

        // 保存最后一次消息用于重试
        let lastMessage = '';
        let isOnline = true;

        // 监听网络状态
        window.addEventListener('online', () => {
            isOnline = true;
            console.log('网络已恢复');
            // 如果有错误消息，自动重试
            const errorMessages = chatArea.querySelectorAll('.message-error');
            if (errorMessages.length > 0 && lastMessage) {
                setTimeout(() => {
                    sendToServer(lastMessage);
                }, 1000);
            }
        });

        window.addEventListener('offline', () => {
            isOnline = false;
            console.log('网络已断开');
        });

        // 发送到AI服务
        async function sendToServer(message) {
            showTyping(true);
            setLoading(true);
            lastMessage = message;

            try {
                // 检查应用是否初始化
                if (!isInitialized) {
                    await initApp();
                }

                // 处理游戏行动
                const response = await app.processAction(message);
                
                // 解析并应用结算块
                let settlementResult = null;
                let settlementError = null;
                try {
                    if (response.rawContent) {
                        const settlement = parseSettlement(response.rawContent);
                        settlementResult = await app.gameStateService.applySettlement(settlement);
                    }
                } catch (error) {
                    console.error('结算处理失败:', error);
                    settlementError = error.message;
                }
                
                // 添加AI消息
                addMessage(response.plot, 'ai');
                
                // 显示结算浮层（如果有结算内容）
                if (settlementResult && settlementResult.success && settlementResult.changes.length > 0) {
                    showSettlementToast(settlementResult.changes);
                }
                
                updateOptions(response.options);

            } catch (error) {
                console.error('请求失败:', error);
                addErrorMessage(error.message || '连接失败，请稍后重试');
            } finally {
                showTyping(false);
                setLoading(false);
            }
        }

        // 添加错误消息（带重试按钮）
        function addErrorMessage(content) {
            if (chatArea.querySelector('.welcome-message')) {
                chatArea.innerHTML = '';
            }

            // 如果不是第一条消息，添加分隔线
            const existingMessages = chatArea.querySelectorAll('.message');
            if (existingMessages.length > 0) {
                const divider = document.createElement('div');
                divider.className = 'message-divider';
                divider.textContent = '——';
                chatArea.appendChild(divider);
            }

            const messageDiv = document.createElement('div');
            messageDiv.className = 'message message-error';

            messageDiv.innerHTML = `
                <div class="section-title">【系统提示】</div>
                <div class="message-content">
                    ${escapeHtml(content)}
                    <br>
                    <button class="retry-btn" onclick="retryLastMessage()">重试</button>
                </div>
            `;

            chatArea.appendChild(messageDiv);
            scrollToBottom();
        }

        // 重试上一次消息
        function retryLastMessage() {
            if (lastMessage) {
                // 移除错误消息和分隔线
                const errorMessages = chatArea.querySelectorAll('.message-error');
                errorMessages.forEach(msg => {
                    const prevDivider = msg.previousElementSibling;
                    if (prevDivider && prevDivider.className === 'message-divider') {
                        prevDivider.remove();
                    }
                    msg.remove();
                });
                // 重新发送
                sendToServer(lastMessage);
            }
        }

        // 显示结算浮层
        function showSettlementToast(changes) {
            const toast = document.createElement('div');
            toast.className = 'settlement-toast';
            
            let content = '<div class="settlement-title">本轮结算</div><div class="settlement-content">';
            
            for (const change of changes) {
                switch (change.type) {
                    case 'item':
                        if (change.action === 'gain') {
                            content += `<div class="settlement-item gain">获得 ${change.name} ×${change.count}</div>`;
                        } else {
                            content += `<div class="settlement-item lose">消耗 ${change.name} ×${change.count}</div>`;
                        }
                        break;
                    case 'relation':
                        const sign = change.change > 0 ? '+' : '';
                        content += `<div class="settlement-item relation">${change.npc} 好感 ${sign}${change.change}</div>`;
                        break;
                    case 'location':
                        content += `<div class="settlement-item location">到达 ${change.location}</div>`;
                        break;
                    case 'time':
                        content += `<div class="settlement-item time">时间流逝 ${change.days} 时辰</div>`;
                        break;
                    case 'gold':
                        if (change.action === 'gain') {
                            content += `<div class="settlement-item gold-gain">获得 ${change.amount} 灏坤石</div>`;
                        } else {
                            content += `<div class="settlement-item gold-lose">消耗 ${change.amount} 灏坤石</div>`;
                        }
                        break;
                    case 'quest':
                        if (change.action === 'start') {
                            content += `<div class="settlement-item quest-start">开始任务：${change.name}</div>`;
                        } else {
                            content += `<div class="settlement-item quest-complete">完成任务：${change.name}</div>`;
                        }
                        break;
                    case 'skill':
                        content += `<div class="settlement-item skill">${change.name} 熟练度 +${change.change}</div>`;
                        break;
                    case 'flag':
                        content += `<div class="settlement-item flag">触发事件标记</div>`;
                        break;
                    case 'encounter':
                        content += `<div class="settlement-item encounter">首次遇见 ${change.npc}</div>`;
                        break;
                }
            }
            
            content += '</div>';
            toast.innerHTML = content;

            // 插入到对话区域最下方（朱批样式）
            const chatArea = document.getElementById('chatArea');
            if (chatArea) {
                chatArea.appendChild(toast);
                // 滚动到底部
                chatArea.scrollTop = chatArea.scrollHeight;
            }

            // 3秒后自动淡出
            setTimeout(() => {
                toast.classList.add('fade-out');
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.remove();
                    }
                }, 500);
            }, 3000);
        }

        // 添加消息到对话区域
        function addMessage(content, type) {
            if (chatArea.querySelector('.welcome-message')) {
                chatArea.innerHTML = '';
            }

            // 如果不是第一条消息，添加分隔线
            const existingMessages = chatArea.querySelectorAll('.message');
            if (existingMessages.length > 0) {
                const divider = document.createElement('div');
                divider.className = 'message-divider';
                divider.textContent = '——';
                chatArea.appendChild(divider);
            }

            const messageDiv = document.createElement('div');
            messageDiv.className = `message message-${type}`;

            // 根据类型添加标题
            let title = '';
            if (type === 'ai') {
                title = '【剧情描述】';
            } else if (type === 'user') {
                title = '【用户行为】';
            } else if (type === 'error') {
                title = '【系统提示】';
            }

            // 渲染剧情文字：添加段首缩进并转换换行符
            const formattedContent = escapeHtml(content)
                .split('\n')
                .map(line => line.trim() ? '　　' + line.trim() : '')
                .join('<br>');

            messageDiv.innerHTML = `
                <div class="section-title">${title}</div>
                <div class="message-content">${formattedContent}</div>
            `;

            chatArea.appendChild(messageDiv);
            scrollToBottom();
        }

        // 滚动到底部
        function scrollToBottom() {
            chatArea.scrollTop = chatArea.scrollHeight;
        }

        // 更新选项按钮
        function updateOptions(options) {
            currentOptions = options || [];
            optionsArea.innerHTML = '';

            currentOptions.forEach(option => {
                const btn = document.createElement('button');
                btn.className = 'option-btn';
                // 去除 Markdown 格式标记（** 粗体、* 斜体）
                const cleanOption = option.replace(/\*\*/g, '').replace(/\*/g, '');
                btn.textContent = cleanOption;
                btn.onclick = function() {
                    inputBox.value = cleanOption;
                    sendMessage();
                };
                optionsArea.appendChild(btn);
            });

            // 更新选项数量显示
            updateOptionsToggleText();
        }

        // 切换选项面板展开/收起
        let isOptionsExpanded = false;
        function toggleOptions() {
            isOptionsExpanded = !isOptionsExpanded;
            const panel = document.getElementById('optionsPanel');
            const content = document.getElementById('optionsContent');
            const icon = document.querySelector('.options-toggle-icon');

            if (isOptionsExpanded) {
                panel.classList.add('expanded');
                content.style.maxHeight = content.scrollHeight + 'px';
                icon.textContent = '▼';
            } else {
                panel.classList.remove('expanded');
                content.style.maxHeight = '0';
                icon.textContent = '▲';
            }

            updateOptionsToggleText();
        }

        // 更新选项切换按钮文字
        function updateOptionsToggleText() {
            const text = document.querySelector('.options-toggle-text');
            const count = currentOptions.length;
            if (count > 0) {
                text.textContent = isOptionsExpanded ? '收起行动选项' : `展开行动选项 (${count})`;
            } else {
                text.textContent = '暂无行动选项';
            }
        }

        // 显示/隐藏正在输入
        function showTyping(show) {
            typingIndicator.classList.toggle('show', show);
            if (show) {
                scrollToBottom();
            }
        }

        // 设置加载状态
        function setLoading(loading) {
            sendBtn.disabled = loading;
            inputBox.disabled = loading;
            sendBtn.style.opacity = loading ? '0.5' : '1';
            
            const optionBtns = optionsArea.querySelectorAll('.option-btn');
            optionBtns.forEach(btn => {
                btn.disabled = loading;
            });
        }

        // HTML转义，防止XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // 重置游戏
        async function resetGame() {
            if (!confirm('确定要开始新的游戏吗？当前进度将会丢失。')) {
                return;
            }

            try {
                // 检查应用是否初始化
                if (!isInitialized) {
                    await initApp();
                }

                // 重置游戏
                await app.resetGame();

                chatArea.innerHTML = `
                    <div class="welcome-message">
                        <h2>新的修仙之旅</h2>
                        <p>一切从头开始，祝道友仙运昌隆</p>
                    </div>
                `;

                optionsArea.innerHTML = '';
                inputBox.value = '';

                setTimeout(() => {
                    sendToServer('开始');
                }, 500);

            } catch (error) {
                console.error('重置失败:', error);
                alert('重置游戏失败，请稍后重试');
            }
        }

        // ========== 角色面板功能 ==========

        // 打开角色面板
        async function openCharacterPanel() {
            const overlay = document.getElementById('characterPanelOverlay');
            const content = document.getElementById('characterPanelContent');

            overlay.classList.add('show');

            // 检查应用是否初始化
            if (!isInitialized) {
                await initApp();
            }

            // 获取当前角色
            const character = await app.getCurrentCharacter();

            if (!character) {
                content.innerHTML = '<div class="loading-text">请先创建或选择角色</div>';
                return;
            }

            // 显示加载中
            content.innerHTML = '<div class="loading-text">加载角色信息...</div>';

            try {
                renderCharacterPanel(character);

            } catch (error) {
                console.error('加载角色信息失败:', error);
                content.innerHTML = '<div class="loading-text">加载失败，请重试</div>';
            }
        }

        // 关闭角色面板
        function closeCharacterPanel(event) {
            // 如果点击的是关闭按钮或遮罩层，则关闭
            if (!event || event.target.id === 'characterPanelOverlay' || event.target.classList.contains('close-btn')) {
                const overlay = document.getElementById('characterPanelOverlay');
                overlay.classList.remove('show');
            }
        }

        // 渲染角色面板
        function renderCharacterPanel(char) {
            const content = document.getElementById('characterPanelContent');

            // 使用正确的字段名
            const currentHp = char.hp || 100;
            const maxHp = char.hp || 100;  // 当前版本没有max_hp，使用hp代替
            const currentMp = char.mp || 80;
            const maxMp = char.mp || 80;   // 当前版本没有max_mp，使用mp代替

            const hpPercent = Math.round((currentHp / maxHp) * 100);
            const mpPercent = Math.round((currentMp / maxMp) * 100);

            content.innerHTML = `
                <!-- 基本信息 -->
                <div class="char-section">
                    <div class="char-section-title">基本信息</div>
                    <div class="char-info-grid">
                        <div class="char-info-item">
                            <span class="char-info-label">姓名</span>
                            <span class="char-info-value">${char.name}</span>
                        </div>
                        <div class="char-info-item">
                            <span class="char-info-label">性别</span>
                            <span class="char-info-value">${char.gender || '未知'}</span>
                        </div>
                        <div class="char-info-item">
                            <span class="char-info-label">年龄</span>
                            <span class="char-info-value">${char.age || '未知'}岁</span>
                        </div>
                        <div class="char-info-item">
                            <span class="char-info-label">战力</span>
                            <span class="char-info-value">${char.combat_power || 100}</span>
                        </div>
                        <div class="char-info-item">
                            <span class="char-info-label">灵根</span>
                            <span class="char-info-value">${
                                char.spiritual_root_type && char.spiritual_root_elements 
                                    ? `${char.spiritual_root_type}(${char.spiritual_root_elements})`
                                    : char.spiritualRoot || '未设定'
                            }</span>
                        </div>
                        <div class="char-info-item">
                            <span class="char-info-label">出身</span>
                            <span class="char-info-value">${char.background || '未知'}</span>
                        </div>
                        <div class="char-info-item">
                            <span class="char-info-label">身份</span>
                            <span class="char-info-value">${char.identity || '修仙者'}</span>
                        </div>
                    </div>
                </div>

                <!-- 当前状态 -->
                <div class="char-section">
                    <div class="char-section-title">当前状态</div>
                    <div class="attr-bar">
                        <div class="attr-bar-header">
                            <span class="attr-bar-label">生命</span>
                            <span class="attr-bar-value">${currentHp}/${maxHp}</span>
                        </div>
                        <div class="attr-bar-track">
                            <div class="attr-bar-fill" style="width: ${hpPercent}%"></div>
                        </div>
                    </div>
                    <div class="attr-bar">
                        <div class="attr-bar-header">
                            <span class="attr-bar-label">灵力</span>
                            <span class="attr-bar-value">${currentMp}/${maxMp}</span>
                        </div>
                        <div class="attr-bar-track">
                            <div class="attr-bar-fill mp" style="width: ${mpPercent}%"></div>
                        </div>
                    </div>
                </div>

                <!-- 基础属性 -->
                <div class="char-section">
                    <div class="char-section-title">基础属性</div>
                    <div class="char-info-grid">
                        <div class="char-info-item">
                            <span class="char-info-label">根骨</span>
                            <span class="char-info-value">${char.attributes?.根骨 || char.根骨 || 50}</span>
                        </div>
                        <div class="char-info-item">
                            <span class="char-info-label">悟性</span>
                            <span class="char-info-value">${char.attributes?.悟性 || char.悟性 || 50}</span>
                        </div>
                        <div class="char-info-item">
                            <span class="char-info-label">气运</span>
                            <span class="char-info-value">${char.attributes?.气运 || char.气运 || 50}</span>
                        </div>
                        <div class="char-info-item">
                            <span class="char-info-label">魅力</span>
                            <span class="char-info-value">${char.attributes?.魅力 || char.魅力 || 50}</span>
                        </div>
                        <div class="char-info-item">
                            <span class="char-info-label">身法</span>
                            <span class="char-info-value">${char.attributes?.身法 || char.身法 || 50}</span>
                        </div>
                        <div class="char-info-item">
                            <span class="char-info-label">神识</span>
                            <span class="char-info-value">${char.attributes?.神识 || char.神识 || 50}</span>
                        </div>
                    </div>
                </div>

                <!-- 修炼属性 -->
                <div class="char-section">
                    <div class="char-section-title">修炼属性</div>
                    <div class="char-info-grid">
                        <div class="char-info-item">
                            <span class="char-info-label">修为</span>
                            <span class="char-info-value">${char.cultivation || 0}</span>
                        </div>
                        <div class="char-info-item">
                            <span class="char-info-label">体质</span>
                            <span class="char-info-value">${char.special_constitution || '无'}</span>
                        </div>
                    </div>
                </div>

                <!-- 性格 -->
                ${char.personality ? `
                <div class="char-section">
                    <div class="char-section-title">性格</div>
                    <div class="char-text-info">${char.personality}</div>
                </div>
                ` : ''}

                <!-- 外貌 -->
                ${char.appearance ? `
                <div class="char-section">
                    <div class="char-section-title">外貌</div>
                    <div class="char-text-info">${char.appearance}</div>
                </div>
                ` : ''}
            `;
        }

        // ========== 门派面板功能 ==========

        // 打开门派面板
        async function openSectPanel() {
            const overlay = document.getElementById('sectPanelOverlay');
            const content = document.getElementById('sectPanelContent');

            overlay.classList.add('show');

            // 检查应用是否初始化
            if (!isInitialized) {
                await initApp();
            }

            // 显示加载中
            content.innerHTML = '<div class="loading-text">正在寻访仙门...</div>';

            try {
                // 获取静态门派数据
                const staticData = app.getStaticData();
                const sects = staticData.sects;
                renderSectPanel(sects);

            } catch (error) {
                console.error('加载门派信息失败:', error);
                content.innerHTML = '<div class="loading-text">寻访失败，请重试</div>';
            }
        }

        // 关闭门派面板
        function closeSectPanel(event) {
            // 如果点击的是关闭按钮或遮罩层，则关闭
            if (!event || event.target.id === 'sectPanelOverlay' || event.target.classList.contains('close-btn')) {
                const overlay = document.getElementById('sectPanelOverlay');
                overlay.classList.remove('show');
            }
        }

        // 渲染门派面板
        function renderSectPanel(sects) {
            const content = document.getElementById('sectPanelContent');

            if (!sects || sects.length === 0) {
                content.innerHTML = '<div class="loading-text">暂无仙门信息</div>';
                return;
            }

            content.innerHTML = `
                <div class="sect-list">
                    ${sects.map(sect => `
                        <div class="sect-card" onclick="showSectDetail(${sect.id}, '${escapeHtml(sect.name)}')">
                            <div class="sect-card-header">
                                <h3>${sect.name}</h3>
                                <span class="sect-country">${sect.country}</span>
                            </div>
                            <div class="sect-card-body">
                                <p class="sect-description">${sect.description}</p>
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        // 显示门派详情
        async function showSectDetail(sectId, sectName) {
            const overlay = document.getElementById('sectDetailOverlay');
            const content = document.getElementById('sectDetailContent');

            overlay.classList.add('show');
            content.innerHTML = '<div class="loading-text">正在查探详情...</div>';

            try {
                // 检查应用是否初始化
                if (!isInitialized) {
                    await initApp();
                }

                // 从前端静态数据获取门派详情
                const staticData = app.getStaticData();
                const sect = staticData.sects.find(s => s.id == sectId);
                
                if (!sect) {
                    throw new Error('门派不存在');
                }

                renderSectDetail(sect);

            } catch (error) {
                console.error('加载门派详情失败:', error);
                content.innerHTML = '<div class="loading-text">查探失败，请重试</div>';
            }
        }

        // 关闭门派详情弹窗
        function closeSectDetail(event) {
            // 如果点击的是关闭按钮或遮罩层，则关闭
            if (!event || event.target.id === 'sectDetailOverlay' || event.target.classList.contains('close-btn')) {
                const overlay = document.getElementById('sectDetailOverlay');
                overlay.classList.remove('show');
            }
        }

        // 渲染门派详情
        function renderSectDetail(sect) {
            const content = document.getElementById('sectDetailContent');

            content.innerHTML = `
                <div class="sect-detail-section">
                    <h3 class="sect-detail-name">${sect.name}</h3>
                    <div class="sect-detail-info">
                        <div class="sect-detail-item">
                            <span class="sect-detail-label">所在地</span>
                            <span class="sect-detail-value">${sect.country}</span>
                        </div>
                        ${sect.leader_title && sect.leader_name ? `
                        <div class="sect-detail-item">
                            <span class="sect-detail-label">领袖</span>
                            <span class="sect-detail-value">${sect.leader_title} ${sect.leader_name}</span>
                        </div>
                        ` : ''}
                        ${sect.speciality ? `
                        <div class="sect-detail-item">
                            <span class="sect-detail-label">门派特色</span>
                            <span class="sect-detail-value">${sect.speciality}</span>
                        </div>
                        ` : ''}
                    </div>
                </div>

                <div class="sect-detail-section">
                    <h4 class="sect-detail-section-title">门派描述</h4>
                    <p class="sect-detail-description">${sect.description}</p>
                </div>

                <div class="sect-detail-actions">
                    <button class="sect-join-btn" onclick="joinSect(${sect.id}, '${sect.name}')">拜入山门</button>
                    ${currentCharacter && currentCharacter.id ? `
                    <button class="sect-task-btn" onclick="checkSectMembership(${sect.id}, '${sect.name}')">领取任务</button>
                    ` : ''}
                </div>
            `;
        }

        // 加入门派
        async function joinSect(sectId, sectName) {
            // 获取当前角色ID
            const characterId = currentCharacter?.id;
            if (!characterId) {
                alert('请先创建角色');
                return;
            }

            // 检查角色是否已有门派
            try {
                // 检查应用是否初始化
                if (!isInitialized) {
                    await initApp();
                }

                // 前端模拟加入门派
                const message = `你成功加入了${sectName}，成为了门派的一员！`;
                
                // 关闭详情弹窗
                closeSectDetail();
                
                // 在游戏对话区域显示消息
                addMessage(message, 'ai');
                
                // 提示用户
                alert(message);
                
            } catch (error) {
                console.error('加入门派失败:', error);
                alert('操作失败，请稍后重试');
            }
        }

        // 检查门派成员资格
        async function checkSectMembership(sectId, sectName) {
            const characterId = currentCharacter?.id;
            if (!characterId) {
                alert('请先创建角色');
                return;
            }

            // 直接调用生成任务接口，由后端检查成员资格
            generateTask(sectId, sectName);
        }

        // 生成门派任务
        async function generateTask(sectId, sectName) {
            const characterId = currentCharacter?.id;
            if (!characterId) {
                alert('请先创建角色');
                return;
            }

            const overlay = document.getElementById('taskDetailOverlay');
            const content = document.getElementById('taskDetailContent');

            overlay.classList.add('show');
            content.innerHTML = '<div class="loading-text">正在生成任务...</div>';

            try {
                // 检查应用是否初始化
                if (!isInitialized) {
                    await initApp();
                }

                // 前端模拟生成任务
                const task = {
                    id: Date.now(),
                    title: '门派任务',
                    description: '门派需要你完成一项重要任务，这是对你的考验',
                    requirements: '炼气一层以上',
                    rewards: '100点门派贡献',
                    deadline: '3天后',
                    status: '未接受'
                };
                
                renderTaskDetail(task, sectName);

            } catch (error) {
                console.error('生成任务失败:', error);
                alert('操作失败，请稍后重试');
                closeTaskDetail();
            }
        }

        // 关闭任务详情弹窗
        function closeTaskDetail(event) {
            if (!event || event.target.id === 'taskDetailOverlay' || event.target.classList.contains('close-btn')) {
                const overlay = document.getElementById('taskDetailOverlay');
                overlay.classList.remove('show');
            }
        }

        // 渲染任务详情
        function renderTaskDetail(task, sectName) {
            const content = document.getElementById('taskDetailContent');

            content.innerHTML = `
                <div class="task-detail-section">
                    <h3 class="task-detail-name">${task.title}</h3>
                    <div class="task-detail-info">
                        <div class="task-detail-item">
                            <span class="task-detail-label">发布门派</span>
                            <span class="task-detail-value">${sectName}</span>
                        </div>
                        <div class="task-detail-item">
                            <span class="task-detail-label">奖励</span>
                            <span class="task-detail-value">${task.rewards}</span>
                        </div>
                        <div class="task-detail-item">
                            <span class="task-detail-label">要求</span>
                            <span class="task-detail-value">${task.requirements}</span>
                        </div>
                        <div class="task-detail-item">
                            <span class="task-detail-label">截止时间</span>
                            <span class="task-detail-value">${task.deadline}</span>
                        </div>
                    </div>
                </div>

                <div class="task-detail-section">
                    <h4 class="task-detail-section-title">任务描述</h4>
                    <p class="task-detail-description">${task.description}</p>
                </div>

                <div class="task-detail-actions">
                    <button class="task-execute-btn">执行任务</button>
                </div>
            `;
        }

        // 打开地图
        function openMap() {
            const overlay = document.getElementById('mapPanelOverlay');
            overlay.classList.add('show');
            initMap();
        }

        // 关闭地图
        function closeMap(event) {
            const overlay = document.getElementById('mapPanelOverlay');
            overlay.classList.remove('show');
        }

        // 地图前端逻辑
        let mapState = {
            layer: "world",
            worldId: 1,
            realmId: null,
            regionId: null,
            locationId: null,
            buildingId: null,
            selectedNode: null,
        };

        // 层级标签配置
        const mapLayerLabels = {
            world:    ["", "世界总览", "点击任意界进入"],
            realm:    ["", "界域地图", "点击区域查看详情"],
            region:   ["", "区域地图", "点击地点查看详情"],
            location: ["", "地点详图", "点击建筑查看内部"],
            building: ["", "建筑内部", "各空间详情"],
        };

        // 类型映射
        const mapTypeMap = {
            // 界域类型
            heaven: "天界",
            mortal: "人间",
            immortal: "仙门",
            underworld: "幽都",
            demon: "妖域",
            nanya: "南邺",
            // 地点类型
            sect: "门派",
            town: "城镇",
            village: "村落",
            wilderness: "荒野",
            mountain: "山脉",
            river: "河流",
            forest: "森林",
            // 建筑类型
            building: "建筑",
            hall: "殿堂",
            tower: "楼阁",
            courtyard: "庭院",
            cave: "洞窟",
            platform: "高台",
            pavilion: "亭阁",
            room: "房间",
            garden: "园林",
            library: "藏书阁",
            training: "修炼场",
            residence: "居所",
            alchemy: "炼丹房",
            forge: "锻造坊"
        };

        // 地图数据获取函数
        async function mapApi(path) {
            try {
                // 检查应用是否初始化
                if (!isInitialized) {
                    await initApp();
                }
                
                // 获取静态地图数据
                const staticData = app.getStaticData();
                
                // 根据路径返回相应数据
                if (path === "/world") {
                    return staticData;
                } else if (path.startsWith("/realm/")) {
                    const realmId = path.split("/").pop();
                    const realm = staticData.realms.find(r => r.id == realmId || r.slug == realmId);
                    return realm;
                } else if (path.startsWith("/region/")) {
                    const regionId = path.split("/").pop();
                    // 查找所有区域
                    for (const realm of staticData.realms) {
                        if (realm.regions) {
                            const region = realm.regions.find(r => r.id == regionId || r.slug == regionId);
                            if (region) {
                                // 添加 realm_name 和 realm_id 字段用于面包屑显示
                                return { ...region, realm_name: realm.name, realm_id: realm.id };
                            }
                        }
                    }
                    return null;
                } else if (path.startsWith("/location/")) {
                    const locationId = path.split("/").pop();
                    console.log('mapApi looking for location:', locationId, 'type:', typeof locationId);
                    // 查找所有地点（包括嵌套的 sub_locations）
                    for (const realm of staticData.realms) {
                        // 检查 realm.locations
                        if (realm.locations) {
                            const location = realm.locations.find(l => l.id == locationId);
                            if (location) {
                                return { ...location, realm_name: realm.name, realm_id: realm.id };
                            }
                            // 检查 location.sub_locations（包括嵌套的）
                            for (const loc of realm.locations) {
                                if (loc.sub_locations) {
                                    const subLoc = loc.sub_locations.find(l => l.id == locationId);
                                    if (subLoc) {
                                        return { ...subLoc, realm_name: realm.name, realm_id: realm.id, location_name: loc.name, location_id: loc.id };
                                    }
                                    // 检查嵌套的 sub_locations（第三级）
                                    for (const sub of loc.sub_locations) {
                                        if (sub.sub_locations) {
                                            const nestedSub = sub.sub_locations.find(l => l.id == locationId);
                                            if (nestedSub) {
                                                return { ...nestedSub, realm_name: realm.name, realm_id: realm.id, location_name: loc.name, location_id: loc.id, sub_location_name: sub.name, sub_location_id: sub.id };
                                            }
                                            // 检查第四级嵌套
                                            for (const nested of sub.sub_locations) {
                                                if (nested.sub_locations) {
                                                    const deepSub = nested.sub_locations.find(l => l.id == locationId);
                                                    if (deepSub) {
                                                        return { ...deepSub, realm_name: realm.name, realm_id: realm.id, location_name: loc.name, location_id: loc.id, sub_location_name: sub.name, sub_location_id: sub.id, nested_location_name: nested.name, nested_location_id: nested.id };
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (realm.regions) {
                            for (const region of realm.regions) {
                                if (region.locations) {
                                    const location = region.locations.find(l => l.id == locationId);
                                    if (location) {
                                        return { ...location, realm_name: realm.name, realm_id: realm.id, region_name: region.name, region_id: region.id };
                                    }
                                    // 检查 location.sub_locations（包括嵌套的）
                                    for (const loc of region.locations) {
                                        if (loc.sub_locations) {
                                            console.log('checking location:', loc.name, 'sub_locations:', loc.sub_locations.map(s => s.id));
                                            const subLoc = loc.sub_locations.find(l => l.id == locationId);
                                            if (subLoc) {
                                                console.log('found subLoc:', subLoc.name);
                                                return { ...subLoc, realm_name: realm.name, realm_id: realm.id, region_name: region.name, region_id: region.id, location_name: loc.name, location_id: loc.id };
                                            }
                                            // 检查嵌套的 sub_locations（第三级，如苍斛街的分段）
                                            for (const sub of loc.sub_locations) {
                                                if (sub.sub_locations) {
                                                    console.log('checking nested sub:', sub.name, 'sub_locations:', sub.sub_locations.map(s => s.id));
                                                    const nestedSub = sub.sub_locations.find(l => l.id == locationId);
                                                    if (nestedSub) {
                                                        console.log('found nestedSub:', nestedSub.name);
                                                        return { ...nestedSub, realm_name: realm.name, realm_id: realm.id, region_name: region.name, region_id: region.id, location_name: loc.name, location_id: loc.id, sub_location_name: sub.name, sub_location_id: sub.id };
                                                    }
                                                    // 检查第四级嵌套（如甲段·北端的商铺）
                                                    for (const nested of sub.sub_locations) {
                                                        if (nested.sub_locations) {
                                                            console.log('checking deeply nested:', nested.name, 'sub_locations:', nested.sub_locations.map(s => s.id));
                                                            const deepSub = nested.sub_locations.find(l => l.id == locationId);
                                                            if (deepSub) {
                                                                console.log('found deepSub:', deepSub.name);
                                                                return { ...deepSub, realm_name: realm.name, realm_id: realm.id, region_name: region.name, region_id: region.id, location_name: loc.name, location_id: loc.id, sub_location_name: sub.name, sub_location_id: sub.id, nested_location_name: nested.name, nested_location_id: nested.id };
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    return null;
                } else if (path.startsWith("/building/")) {
                    const buildingId = path.split("/").pop();
                    // 查找所有建筑（包括 sub_locations）
                    for (const realm of staticData.realms) {
                        if (realm.locations) {
                            for (const location of realm.locations) {
                                // 检查 location.sub_locations
                                if (location.sub_locations) {
                                    const building = location.sub_locations.find(b => b.id == buildingId);
                                    if (building) {
                                        return { ...building, realm_name: realm.name, realm_id: realm.id, location_name: location.name, location_id: location.id };
                                    }
                                    // 检查嵌套的 sub_locations
                                    for (const sub of location.sub_locations) {
                                        if (sub.sub_locations) {
                                            const nested = sub.sub_locations.find(b => b.id == buildingId);
                                            if (nested) {
                                                return { ...nested, realm_name: realm.name, realm_id: realm.id, location_name: location.name, location_id: location.id };
                                            }
                                        }
                                    }
                                }
                                if (location.buildings) {
                                    const building = location.buildings.find(b => b.id == buildingId);
                                    if (building) {
                                        return { ...building, realm_name: realm.name, realm_id: realm.id, location_name: location.name, location_id: location.id };
                                    }
                                }
                            }
                        }
                        if (realm.regions) {
                            for (const region of realm.regions) {
                                if (region.locations) {
                                    for (const location of region.locations) {
                                        // 检查 location.sub_locations
                                        if (location.sub_locations) {
                                            const building = location.sub_locations.find(b => b.id == buildingId);
                                            if (building) {
                                                return { ...building, realm_name: realm.name, realm_id: realm.id, region_name: region.name, region_id: region.id, location_name: location.name, location_id: location.id };
                                            }
                                            // 检查嵌套的 sub_locations
                                            for (const sub of location.sub_locations) {
                                                if (sub.sub_locations) {
                                                    const nested = sub.sub_locations.find(b => b.id == buildingId);
                                                    if (nested) {
                                                        return { ...nested, realm_name: realm.name, realm_id: realm.id, region_name: region.name, region_id: region.id, location_name: location.name, location_id: location.id };
                                                    }
                                                }
                                            }
                                        }
                                        if (location.buildings) {
                                            const building = location.buildings.find(b => b.id == buildingId);
                                            if (building) {
                                                return { ...building, realm_name: realm.name, realm_id: realm.id, region_name: region.name, region_id: region.id, location_name: location.name, location_id: location.id };
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    return null;
                }
                
                return null;
            } catch(e) {
                console.error("Map data error:", path, e);
                return null;
            }
        }

        // 初始化地图
        async function initMap() {
            document.getElementById('map-loading').style.display = 'none';
            await loadMapWorld();
        }

        // 更新层级标题
        function setMapLayerHeader(layer, extra = "") {
            const [pre, main, hint] = mapLayerLabels[layer] || ["", layer, ""];
            document.getElementById("map-layer-header").innerHTML = 
                extra || hint;
        }

        // 加载世界数据
        async function loadMapWorld() {
            console.log('开始加载世界数据...');
            const world = await mapApi("/world");
            console.log('世界数据:', world);
            
            if (!world) {
                console.error('世界数据为空');
                showMapError('加载失败，请刷新重试');
                return;
            }
            
            if (!world.realms || world.realms.length === 0) {
                console.error('世界数据中没有界域:', world);
                showMapError('地图数据不完整，请刷新重试');
                return;
            }
            
            mapState.layer = 'world';
            mapState.realmId = null;
            mapState.regionId = null;
            mapState.locationId = null;
            mapState.buildingId = null;
            mapState.selectedNode = null;
            
            console.log('界域数据:', world.realms);
            renderMapGrid(world.realms);
            setMapLayerHeader('world');
            updateMapBreadcrumb([{ name: '六界', level: 'world' }]);
        }

        // 加载界数据
        async function loadMapRealm(realmId, realmName) {
            const realm = await mapApi(`/realm/${realmId}`);
            if (!realm) return;

            mapState.layer = 'realm';
            mapState.realmId = realmId;
            mapState.regionId = null;
            mapState.locationId = null;
            mapState.buildingId = null;
            mapState.selectedNode = null;

            // 如果有区域，显示区域；否则显示地点
            if (realm.has_regions && realm.regions && realm.regions.length > 0) {
                renderMapGrid(realm.regions);
                setMapLayerHeader('realm');
            } else {
                renderMapGrid(realm.locations);
                setMapLayerHeader('realm');
            }

            updateMapBreadcrumb([
                { name: '六界', level: 'world' },
                { name: realmName || realm.name, level: 'realm', id: realmId }
            ]);
        }

        // 加载区域数据
        async function loadMapRegion(regionId, regionName) {
            const region = await mapApi(`/region/${regionId}`);
            if (!region) return;

            // 设置 realmId
            if (region.realm_id) {
                mapState.realmId = region.realm_id;
            }

            mapState.layer = 'region';
            mapState.regionId = regionId;
            mapState.locationId = null;
            mapState.buildingId = null;
            mapState.selectedNode = null;

            renderMapGrid(region.locations);
            setMapLayerHeader('region');

            updateMapBreadcrumb([
                { name: '六界', level: 'world' },
                { name: region.realm_name, level: 'realm', id: mapState.realmId },
                { name: regionName || region.name, level: 'region', id: regionId }
            ]);
        }

        // 加载地点数据
        async function loadMapLocation(locationId, locationName) {
            console.log('loadMapLocation called:', locationId, locationName);
            const location = await mapApi(`/location/${locationId}`);
            console.log('loadMapLocation api result:', location);
            if (!location) {
                console.log('loadMapLocation: no location found');
                return;
            }

            // 判断层级：有 nested_location_id 表示是第四级嵌套，有 sub_location_id 表示是第三级，有 location_id 表示是第二级
            const isDeeplyNested = !!location.nested_location_id;
            const isNestedSubLocation = !!location.sub_location_id;
            const isSubLocation = !!location.location_id;

            // 设置 realmId 和 regionId（始终覆盖，确保正确）
            if (location.realm_id) {
                mapState.realmId = location.realm_id;
            }
            if (location.region_id) {
                mapState.regionId = location.region_id;
            }

            // 保存父级的 ID（用于面包屑导航）
            const parentLocationId = isSubLocation ? location.location_id : null;
            const parentSubLocationId = isNestedSubLocation ? location.sub_location_id : null;
            const parentNestedId = isDeeplyNested ? location.nested_location_id : null;

            // 确定当前层级
            if (isDeeplyNested || isNestedSubLocation) {
                mapState.layer = 'building';
            } else if (isSubLocation) {
                mapState.layer = 'building';
            } else {
                mapState.layer = 'location';
            }
            mapState.locationId = locationId;
            mapState.buildingId = null;
            mapState.selectedNode = null;

            console.log('loadMapLocation:', location.name, 'isSubLocation:', isSubLocation, 'isNested:', isNestedSubLocation, 'isDeep:', isDeeplyNested, 'subNodes:', location.sub_locations);

            // 支持 sub_locations 或 buildings
            const subNodes = location.sub_locations || location.buildings;
            if (subNodes && subNodes.length > 0) {
                renderMapGrid(subNodes);
                setMapLayerHeader('building');
            }

            // 更新面包屑
            if (isDeeplyNested) {
                // 第七层：深度嵌套的 sub_location（如苍斛街的分段）
                updateMapBreadcrumb([
                    { name: '六界', level: 'world' },
                    { name: location.realm_name || '人间', level: 'realm', id: mapState.realmId },
                    { name: location.region_name || mapState.regionId, level: 'region', id: mapState.regionId },
                    { name: location.location_name, level: 'location', id: parentLocationId },
                    { name: location.sub_location_name, level: 'location', id: parentSubLocationId },
                    { name: location.nested_location_name, level: 'location', id: parentNestedId },
                    { name: locationName || location.name, level: 'building', id: locationId }
                ]);
            } else if (isNestedSubLocation) {
                // 第六层：嵌套的 sub_location
                updateMapBreadcrumb([
                    { name: '六界', level: 'world' },
                    { name: location.realm_name || '人间', level: 'realm', id: mapState.realmId },
                    { name: location.region_name || mapState.regionId, level: 'region', id: mapState.regionId },
                    { name: location.location_name, level: 'location', id: parentLocationId },
                    { name: location.sub_location_name, level: 'location', id: parentSubLocationId },
                    { name: locationName || location.name, level: 'building', id: locationId }
                ]);
            } else if (isSubLocation) {
                // 第五层：sub_location
                updateMapBreadcrumb([
                    { name: '六界', level: 'world' },
                    { name: location.realm_name || '人间', level: 'realm', id: mapState.realmId },
                    { name: location.region_name || mapState.regionId, level: 'region', id: mapState.regionId },
                    { name: location.location_name, level: 'location', id: parentLocationId },
                    { name: locationName || location.name, level: 'building', id: locationId }
                ]);
            } else {
                // 第四层：location
                updateMapBreadcrumb([
                    { name: '六界', level: 'world' },
                    { name: location.realm_name || '人间', level: 'realm', id: mapState.realmId },
                    { name: location.region_name || mapState.regionId, level: 'region', id: mapState.regionId },
                    { name: locationName || location.name, level: 'location', id: locationId }
                ]);
            }

            showMapDetail(location, location);
        }

        // 加载建筑数据
        async function loadMapBuilding(buildingId, buildingName) {
            const building = await mapApi(`/building/${buildingId}`);
            if (!building) return;

            // 设置 realmId 和 regionId
            if (building.realm_id) {
                mapState.realmId = building.realm_id;
            }
            if (building.region_id) {
                mapState.regionId = building.region_id;
            }
            if (building.location_id) {
                mapState.locationId = building.location_id;
            }

            mapState.layer = 'building';
            mapState.buildingId = buildingId;
            mapState.selectedNode = null;

            // 支持 sub_locations 或 rooms
            const subNodes = building.sub_locations || building.rooms;
            if (subNodes && subNodes.length > 0) {
                renderMapGrid(subNodes);
            }

            setMapLayerHeader('building');

            // 更新面包屑
            updateMapBreadcrumb([
                { name: '六界', level: 'world' },
                { name: building.realm_name || '人间', level: 'realm', id: mapState.realmId },
                { name: building.region_name || mapState.regionId, level: 'region', id: mapState.regionId },
                { name: building.location_name || mapState.locationId, level: 'location', id: mapState.locationId },
                { name: buildingName, level: 'building', id: buildingId }
            ]);

            showMapDetail(building, building);
        }

        // 渲染节点网格
        function renderMapGrid(nodes) {
            const grid = document.getElementById("map-node-grid");
            if (!nodes || nodes.length === 0) {
                grid.innerHTML = '<div class="map-empty-state">此处尚无记录</div>';
                return;
            }
            grid.innerHTML = nodes.map(n => mapNodeCard(n)).join("");
        }

        // 创建节点卡片
        function mapNodeCard(n) {
            const locked = n.is_accessible === false;
            const typeLabel = mapTypeMap[n.realm_type || n.region_type || n.location_type || n.building_type] || "";
            const danger = n.danger_level || 0;
            const dots = danger > 0
                ? `<div class="map-danger-dots">${[1,2,3,4,5].map(i=>`<div class="map-dot${i<=danger?' active':''}"></div>`).join("")}</div>`
                : "";
            const subText = n.atmosphere
                ? n.atmosphere.slice(0, 36) + (n.atmosphere.length > 36 ? "…" : "")
                : (n.description ? n.description.slice(0, 36) + "…" : "");

            const tag = locked
                ? `<span class="map-node-tag locked-tag">🔒 未解锁</span>`
                : "";

            return `
                <div class="map-node-card${locked ? " locked" : ""}"
                     data-id="${n.id}"
                     data-slug="${n.slug || ""}"
                     data-type="${n.realm_type || n.region_type || n.location_type || n.building_type || ""}"
                     data-accessible="${!locked}"
                     onclick="onMapNodeClick(this, ${JSON.stringify(n).replace(/"/g, '&quot;')})"
                     ondblclick="onMapNodeDblClick(this, ${JSON.stringify(n).replace(/"/g, '&quot;')})")">
                    ${dots}
                    <div class="map-node-name">${n.name}</div>
                    <div class="map-node-sub">${subText}</div>
                    ${tag}
                    <span class="map-drill-arrow">→</span>
                </div>`;
        }

        // 节点点击处理
        function onMapNodeClick(element, nodeData) {
            // 移除其他选中状态
            document.querySelectorAll('.map-node-card').forEach(c => c.classList.remove('selected'));
            // 添加选中状态
            element.classList.add('selected');
            
            mapState.selectedNode = { node: nodeData, element: element };
            showMapDetail(nodeData, nodeData);
        }

        // 节点双击处理
        function onMapNodeDblClick(element, nodeData) {
            if (nodeData.is_accessible !== false) {
                enterMapNode(nodeData, getMapNodeType(nodeData));
            }
        }

        // 获取节点类型
        function getMapNodeType(node) {
            if (node.realm_type) return 'realm';
            if (node.region_type) return 'region';
            if (node.building_type) return 'building';
            if (node.location_type) return node.location_type;
            // 如果有 sub_locations 或 buildings，视为 location
            if (node.sub_locations || node.buildings) return 'location';
            return 'location';
        }

        // 进入节点
        function enterMapNode(node, type) {
            console.log('enterMapNode:', type, node.name, 'sub_locations:', node.sub_locations);
            switch (type) {
                case 'realm':
                    loadMapRealm(node.slug || node.id, node.name);
                    break;
                case 'region':
                    loadMapRegion(node.id, node.name);
                    break;
                case 'location':
                case 'sect':
                case 'town':
                case 'village':
                case 'city':
                case 'palace':
                    console.log('enterMapNode: calling loadMapLocation for', node.name, 'id:', node.id);
                    loadMapLocation(node.id, node.name);
                    break;
                case 'building':
                case 'hall':
                case 'tower':
                case 'courtyard':
                case 'cave':
                case 'platform':
                case 'pavilion':
                    loadMapBuilding(node.id, node.name);
                    break;
            }
        }

        // 显示详情
        function showMapDetail(node, fullData) {
            const panel = document.getElementById('map-detail-panel');

            console.log('showMapDetail:', fullData.name, 'sub_locations:', fullData.sub_locations);

            let html = `
                <div class="map-detail-title">${fullData.name}</div>
                <hr class="map-detail-divider">`;

            if (fullData.description) {
                html += `<div class="map-detail-section"><label>简介</label><p>${fullData.description}</p></div>`;
            }
            if (fullData.atmosphere) {
                html += `<div class="map-detail-section"><label>氛围</label><p>${fullData.atmosphere}</p></div>`;
            }
            if (fullData.access_rule) {
                html += `<div class="map-detail-section"><label>进入条件</label><p>${fullData.access_rule}</p></div>`;
            }
            if (fullData.ruler) {
                html += `<div class="map-detail-section"><label>掌管者</label><p>${fullData.ruler}</p></div>`;
            }

            // 检查是否有子地点可以进入
            const hasSubLocations = fullData.sub_locations && fullData.sub_locations.length > 0;
            const hasBuildings = fullData.buildings && fullData.buildings.length > 0;
            const hasRegions = fullData.regions && fullData.regions.length > 0;
            const hasLocations = fullData.locations && fullData.locations.length > 0;
            const canEnter = hasSubLocations || hasBuildings || hasRegions || hasLocations;
            
            if (canEnter) {
                html += `<button class="map-btn-enter"
                           onclick="drillInMap(${JSON.stringify(fullData).replace(/"/g,'&quot;')})"">
                           进　入
                         </button>`;
            }

            panel.innerHTML = html;
        }

        // 导航到子节点
        function navigateToMapChild(childData) {
            const type = getMapNodeType(childData);
            enterMapNode(childData, type);
        }

        // 钻入节点
        function drillInMap(nodeData) {
            console.log('drillInMap:', nodeData.name, 'type:', getMapNodeType(nodeData), 'sub:', nodeData.sub_locations);
            const type = getMapNodeType(nodeData);
            enterMapNode(nodeData, type);
        }

        // 更新面包屑
        function updateMapBreadcrumb(items) {
            const crumb = document.getElementById('map-breadcrumb');
            crumb.innerHTML = items.map((item, index) => {
                const isLast = index === items.length - 1;
                const activeClass = isLast ? 'active' : '';
                const onclick = isLast ? '' : `onclick="navigateToMap('${item.level}', '${item.id || ''}')"`;
                return `
                    <span class="map-crumb ${activeClass}" ${onclick}>${item.name}</span>
                    ${isLast ? '' : '<span class="map-crumb-sep">›</span>'}
                `;
            }).join('');
        }

        // 面包屑导航
        function navigateToMap(level, id) {
            switch (level) {
                case 'world':
                    loadMapWorld();
                    break;
                case 'realm':
                    if (id) loadMapRealm(id);
                    break;
                case 'region':
                    if (id) loadMapRegion(id);
                    break;
                case 'location':
                    if (id) loadMapLocation(id);
                    break;
                case 'building':
                    if (id) loadMapLocation(id);
                    break;
            }
        }

        // 显示错误
        function showMapError(msg) {
            document.getElementById('map-node-grid').innerHTML = `
                <div style="text-align: center; color: #c47070; padding: 40px;">
                    ${msg}
                </div>
            `;
        }

        // ==================== 存档管理系统 ====================
        
        // 渲染存档位列表
        async function renderSaveSlots() {
            const container = document.getElementById('saveSlotsList');
            if (!container) return;
            
            try {
                // 检查 app 和 storageService 是否初始化
                if (!app || !app.storageService || !app.storageService.db) {
                    console.log('IndexedDB 未初始化，尝试初始化...');
                    if (app && app.storageService) {
                        await app.storageService.init();
                    }
                }
                
                const slots = await app.getAllSaveSlots();
                const slotsMap = {};
                slots.forEach(slot => {
                    slotsMap[slot.slot_id] = slot;
                });
                
                let html = '';
                for (let i = 1; i <= 10; i++) {
                    const slot = slotsMap[i];
                    if (slot) {
                        // 有存档的槽位
                        const date = new Date(slot.timestamp).toLocaleString('zh-CN');
                        const gameData = slot.game_data || {};
                        const conversationCount = gameData.conversationCount || (gameData.conversationHistory || []).length;
                        const eventCount = (gameData.triggeredEvents || []).length;
                        const itemCount = (gameData.inventory || []).length;
                        
                        html += `
                            <div class="save-slot-item" data-slot-id="${i}">
                                <div class="save-slot-number">${i}</div>
                                <div class="save-slot-info">
                                    <div class="save-slot-name">${slot.character_name || '未知角色'}</div>
                                    <div class="save-slot-details">
                                        <span>[位置] ${slot.location || '未知位置'}</span>
                                        <span>[天数] ${slot.game_days || 1}天</span>
                                        <span>[对话] ${conversationCount}条</span>
                                        ${eventCount > 0 ? `<span>[事件] ${eventCount}个</span>` : ''}
                                        ${itemCount > 0 ? `<span>[物品] ${itemCount}个</span>` : ''}
                                    </div>
                                    <div class="save-slot-details" style="margin-top: 4px; font-size: 10px; color: #a8a098;">
                                        <span>[时间] ${date}</span>
                                    </div>
                                    <div class="save-slot-memo" onclick="editMemo(${i}, '${(slot.memo || '').replace(/'/g, "\\'")}')" title="点击编辑备注">
                                        ${slot.memo ? '[备] ' + slot.memo : '[备] 点击添加备注...'}
                                    </div>
                                </div>
                                <div class="save-slot-actions-row">
                                    <button class="save-slot-btn primary" onclick="loadSaveSlot(${i})">读档</button>
                                    <button class="save-slot-btn" onclick="createSaveAtSlot(${i})">覆盖</button>
                                    <button class="save-slot-btn" onclick="exportSaveSlot(${i})">导出</button>
                                    <button class="save-slot-btn danger" onclick="deleteSaveSlot(${i})">删除</button>
                                </div>
                            </div>
                        `;
                    } else {
                        // 空槽位
                        html += `
                            <div class="save-slot-item empty" data-slot-id="${i}">
                                <div class="save-slot-number">${i}</div>
                                <div class="save-slot-info">
                                    <div class="save-slot-name">空存档位</div>
                                    <div class="save-slot-details">点击"新建存档"保存当前游戏进度</div>
                                </div>
                                <div class="save-slot-actions-row">
                                    <button class="save-slot-btn primary" onclick="createSaveAtSlot(${i})">存档</button>
                                </div>
                            </div>
                        `;
                    }
                }
                
                container.innerHTML = html;
            } catch (error) {
                console.error('渲染存档位失败:', error);
                container.innerHTML = `<div style="text-align: center; color: #c44; padding: 20px;">
                    加载存档位失败<br>
                    <small style="color: #888;">${error.message || '未知错误'}</small><br>
                    <button onclick="renderSaveSlots()" style="margin-top: 10px; padding: 5px 15px; background: #8b7355; color: white; border: none; border-radius: 3px; cursor: pointer;">重试</button>
                </div>`;
            }
        }
        
        // 在指定位置创建存档
        async function createSaveAtSlot(slotId) {
            try {
                // 检查是否是覆盖存档
                const existingSlot = await app.loadSlot(slotId);
                if (existingSlot && existingSlot.success && existingSlot.data && existingSlot.data.character_name) {
                    if (!confirm(`存档位 ${slotId} 已有存档「${existingSlot.data.character_name}」，确定要覆盖吗？`)) {
                        return;
                    }
                }

                // 获取当前游戏状态
                const gameState = app.getGameState();
                const currentCharacter = gameState.getCurrentCharacter();
                const currentLocation = gameState.currentLocation;

                if (!currentCharacter) {
                    alert('当前没有角色，无法存档');
                    return;
                }
                
                // 获取对话历史，只保留最近30条
                const fullHistory = gameState.conversationHistory || [];
                const recentHistory = fullHistory.slice(-30);
                
                // 构建存档数据
                const saveData = {
                    character_id: currentCharacter.id,
                    character_name: currentCharacter.name,
                    location: currentLocation || '未知位置',
                    game_days: gameState.gameDays || 1,
                    memo: '',
                    game_data: {
                        // 角色基础数据
                        character: {
                            id: currentCharacter.id,
                            name: currentCharacter.name,
                            sect: currentCharacter.sect,
                            title: currentCharacter.title,
                            personality: currentCharacter.personality,
                            root_bone: currentCharacter.root_bone,
                            comprehension: currentCharacter.comprehension,
                            hp: currentCharacter.hp,
                            mp: currentCharacter.mp,
                            notes: currentCharacter.notes,
                            created_at: currentCharacter.created_at
                        },
                        // 游戏进度
                        location: currentLocation,
                        gameDays: gameState.gameDays,
                        
                        // 对话历史摘要（仅最近30条）
                        conversationHistory: recentHistory,
                        conversationCount: fullHistory.length, // 记录总对话数
                        
                        // 已触发事件列表（如果有）
                        triggeredEvents: gameState.triggeredEvents || [],
                        
                        // 背包数据（如果有）
                        inventory: gameState.inventory || [],
                        
                        // 社交数据（如果有）
                        socialData: {
                            relationships: gameState.relationships || {},
                            reputation: gameState.reputation || {}
                        },
                        
                        // 存档元数据
                        export_info: {
                            version: '1.0',
                            export_time: new Date().toISOString(),
                            full_history_count: fullHistory.length,
                            saved_history_count: recentHistory.length
                        }
                    }
                };
                
                const result = await app.saveSlot(slotId, saveData);
                if (result.success) {
                    alert('存档成功！');
                    renderSaveSlots();
                } else {
                    alert('存档失败: ' + result.message);
                }
            } catch (error) {
                console.error('存档失败:', error);
                alert('存档失败: ' + error.message);
            }
        }
        
        // 新建存档（自动找空位）
        async function createNewSave() {
            try {
                const nextSlot = await app.getNextAvailableSlotId();
                if (!nextSlot) {
                    alert('存档位已满，请删除旧存档后再试');
                    return;
                }
                createSaveAtSlot(nextSlot);
            } catch (error) {
                console.error('创建存档失败:', error);
                alert('创建存档失败: ' + error.message);
            }
        }

        // 快速存档（从时间菜单调用）
        async function saveGame() {
            // 先关闭时间菜单
            hideTimeMenu();
            // 打开设置面板并切换到存档标签
            openSettings();
            // 切换到存档管理标签
            setTimeout(() => {
                const saveTab = document.querySelector('[data-tab="save"]');
                if (saveTab) {
                    saveTab.click();
                }
            }, 100);
        }

        // 快速读档（从时间菜单调用）
        async function loadGame() {
            // 先关闭时间菜单
            hideTimeMenu();
            // 打开设置面板并切换到存档标签
            openSettings();
            // 切换到存档管理标签
            setTimeout(() => {
                const saveTab = document.querySelector('[data-tab="save"]');
                if (saveTab) {
                    saveTab.click();
                }
            }, 100);
        }

        // 读取存档
        async function loadSaveSlot(slotId) {
            try {
                const result = await app.loadSlot(slotId);
                if (!result.success) {
                    alert('读取存档失败: ' + result.message);
                    return;
                }
                
                if (confirm(`确定要读取存档「${result.data.character_name}」吗？\n当前游戏进度将丢失。`)) {
                    // 加载游戏数据
                    const gameData = result.data.game_data;
                    if (gameData && gameData.character) {
                        await app.loadGame(gameData.character.id);
                        alert('存档读取成功！');
                        closeSettings();
                    } else {
                        alert('存档数据不完整');
                    }
                }
            } catch (error) {
                console.error('读取存档失败:', error);
                alert('读取存档失败: ' + error.message);
            }
        }
        
        // 删除存档
        async function deleteSaveSlot(slotId) {
            if (!confirm(`确定要删除存档位 ${slotId} 吗？\n此操作不可恢复。`)) {
                return;
            }
            
            try {
                const result = await app.deleteSlot(slotId);
                if (result.success) {
                    alert('删除成功！');
                    renderSaveSlots();
                } else {
                    alert('删除失败: ' + result.message);
                }
            } catch (error) {
                console.error('删除存档失败:', error);
                alert('删除失败: ' + error.message);
            }
        }
        
        // 导出存档
        async function exportSaveSlot(slotId) {
            try {
                const result = await app.exportSlot(slotId);
                if (!result.success) {
                    alert('导出失败: ' + result.message);
                    return;
                }
                
                // 创建下载链接
                const a = document.createElement('a');
                a.href = result.url;
                a.download = result.filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(result.url);
                
                alert('存档导出成功！');
            } catch (error) {
                console.error('导出存档失败:', error);
                alert('导出失败: ' + error.message);
            }
        }
        
        // 导入存档文件
        function importSaveFile() {
            document.getElementById('saveFileInput').click();
        }
        
        // 处理导入的文件
        async function handleSaveFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            try {
                const text = await file.text();
                const importData = JSON.parse(text);
                
                // 验证文件格式
                if (!importData.slot_data) {
                    alert('无效的存档文件格式');
                    return;
                }
                
                const result = await app.importSlot(importData);
                
                if (result.success) {
                    alert(`存档导入成功！已保存到存档位 ${result.slotId}`);
                    renderSaveSlots();
                } else {
                    // 需要确认是否覆盖
                    if (confirm(result.message)) {
                        const overwriteResult = await app.importSlot(importData, result.slotId, true);
                        if (overwriteResult.success) {
                            alert('存档覆盖成功！');
                            renderSaveSlots();
                        } else {
                            alert('导入失败: ' + overwriteResult.message);
                        }
                    }
                }
            } catch (error) {
                console.error('导入存档失败:', error);
                alert('导入失败: ' + error.message);
            }
            
            // 清空文件输入
            event.target.value = '';
        }
        
        // 编辑备注
        async function editMemo(slotId, currentMemo) {
            const newMemo = prompt('请输入存档备注:', currentMemo || '');
            if (newMemo === null) return; // 用户取消
            
            try {
                const result = await app.updateSlotMemo(slotId, newMemo);
                if (result.success) {
                    renderSaveSlots();
                } else {
                    alert('更新备注失败: ' + result.message);
                }
            } catch (error) {
                console.error('更新备注失败:', error);
                alert('更新备注失败: ' + error.message);
            }
        }
        
        // 在打开设置时渲染存档位（在openSettings函数内部已调用renderSaveSlots）

        // ==================== 角色创建功能 ====================
        
        // 16个角色预设
        const characterPresets = [
            { name: '预设一：剑眉星目', gender: '男', age: 22, personality: '内心长期处于一种低压的紧绷状态，对外界本能地保持戒备，难以轻易松弛。疑心重，不擅信任，内里敏感，但将这份敏感深埋，以冷漠作为外壳。', appearance: '剑眉星目，轮廓分明，肤色偏冷白，薄唇微抿，眼尾微挑，神情淡漠如霜。长发以玉簪束起，余发垂于肩侧，发丝乌黑如墨。内衬白色立领中衣，外罩霜蓝暗纹道袍，袍上以银线绣细碎云纹，腰间系同色系宽腰带，缀一枚青玉玉佩。袖口收紧，绣细边白纹。足踏白底云纹靴，整体简洁利落，不显繁复，却有一股出尘之气。腰间悬一把细长剑鞘，鞘身素白无纹，仅剑柄缠白绸。' },
            { name: '预设二：浓眉大眼', gender: '男', age: 24, personality: '对大多数事提不起强烈的欲望，心态松散，少有执念。不是真的无所求，只是欲望的阈值偏低，容易满足于当下，缺乏向前的紧迫感。', appearance: '浓眉大眼，眼神明亮有神，嘴角常带笑，皮肤因常年练武略显小麦色，透着健康生气。发束成简单高马尾，常有碎发散落额前，显得随性不羁。内着深褐短打劲装，外套一件赤红对襟短袍，袍袖挽至肘部，腰间系一条宽皮革腰带，插着几个装符纸的皮囊。裤腿以布条束紧，足踏厚底黑色武靴，整体干练利落，适合行动。颈间挂一串粗糙的红绳手串，腰侧挂一把宽刃短刀。' },
            { name: '预设三：眉目温和', gender: '男', age: 23, personality: '思维缜密，凡事习惯提前预判，对人对事有清醒的功利意识。情绪稳定，极少冲动，内里有明确的目的性，但懂得将其妥善包裹。', appearance: '眉目温和，眼神清澈含笑，眼尾略下垂带一丝无害感，五官清秀不出挑，却耐看，肤色白净。发束成整齐的单髻，用一支朴素木簪固定，无多余装饰。内着米白素面中衣，外穿青绿色宽袖儒袍，袍身无过多纹样，仅领口袖口处绣细竹叶边。腰间系棉布腰带，挂一个装满草药的布囊。足踏青色布鞋，鞋面干净。' },
            { name: '预设四：眉骨略高', gender: '男', age: 25, personality: '天性中带着一种对自身魅力的自觉与从容，不刻意，却始终游刃有余。情绪流动自然，少有棱角，对世事抱一种懒散的接纳态度。', appearance: '眉骨略高，眉形细长微蹙，眼神幽深带着一丝戒备，瞳色偏深，眼尾微微下垂，常给人一种若有所思的阴郁感。鼻梁挺直，唇色偏淡，嘴角自然下压，少见笑意。肤色冷白，面部轮廓偏硬朗。发色乌黑，以暗色发带随意束于脑后，碎发时常垂落遮住半边眉眼，不甚在意。衣着以玄黑与深灰为主，内衬深灰立领中衣，外罩玄色宽袖长袍，袍身无过多纹样，腰间松松系一条深色布带，缀一枚形制简单的暗色玉牌。足踏黑色厚底靴，整体暗沉低调，少有装饰。' },
            { name: '预设五：眉形舒展', gender: '男', age: 24, personality: '外表呈现出的柔弱与内里的清醒之间存在刻意的落差。善于感知他人情绪并加以利用，本能地倾向于以弱势姿态换取主动权，自我保护意识极强。', appearance: '眉形舒展略粗，眼神懒散带着几分漫不经心，眼型圆润，眼尾微微下弯，瞳色偏暖棕，常给人一种昏昏欲睡的随性感。鼻梁略宽，唇厚色润，嘴角自然微扬，面部轮廓偏圆和，整体长相讨喜。发色棕黑，常常只是随手用一根发绳松松绑住，时常散落大半，不加整理。中衣领口微敞，外袍腰带系得松垮，袖子习惯性地挽上去一截。足踏布面软靴。' },
            { name: '预设六：眉形细而流畅', gender: '男', age: 22, personality: '性情疏离，与外界保持天然的距离感，并不刻意为之，只是本能如此。内里有强烈的自我准则，对认定的事执着，不易被外力撼动，亦不在意旁人的看法。', appearance: '眉形细而流畅，眉尾微扬，眼神温和含笑，笑意却极少抵达眼底，眼型偏长，眼尾上挑，瞳色澄亮。鼻梁挺秀，唇形优美，笑起来弧度恰到好处，面部轮廓偏俊秀精致。发色乌黑，束成整齐的高髻，以玉簪固定，鬓角梳理得一丝不乱。内衬细密织纹中衣，外罩玉白广袖长袍，袍身绣隐纹暗花，腰间系浅金色宽腰封，配件精心挑选，环佩叮当却不显累赘。足踏白面金边软靴，一切都打理得体面周到。' },
            { name: '预设七：眉形细长', gender: '男', age: 23, personality: '情绪外放，感受力强，容易被外界点燃，对事物的投入快且直接。冲动先于理智，少有城府，内里单纯，有一股不计后果的蛮劲。', appearance: '眉形细长略弯，眉尾微微下勾，眼型狭长妩媚，眼尾上挑明显，瞳色偏深，眼波流动。鼻梁挺而略细，唇瓣饱满红润，唇角天生微微上扬，开口前便先像是在笑，面部轮廓偏柔，棱角不锐，整体生得极为耐看。发色乌黑带光，以一支雕纹玉簪半束，余发松松垂于肩背，随行动轻轻晃动。内衬玄色细纹中衣，领口微敞，外罩烟紫广袖长袍，腰带系得不紧，袍身以银线绣流云暗纹，腰间挂一枚雕工细致的紫玉佩，环佩声轻。足踏玄色软底靴，步态不疾不徐。' },
            { name: '预设八：眉形细而温柔', gender: '男', age: 21, personality: '性情平和，少有强烈的情绪起伏，待人自然带着一种包容与体谅。内里柔韧，不张扬，不争锋，却有自己安静的坚持。', appearance: '眉形细而温柔，眉头略蹙，常带一种若有若无的愁绪，眼型偏圆，眼尾微垂，瞳色清亮，眼神湿润，望人时总像是藏着什么委屈说不出口。鼻梁挺秀偏细，唇瓣薄而形好，唇色浅粉，面部轮廓柔和无害，整体生得清秀。发色偏软的深棕黑，以浅色发带松松半束，余发垂散，碎发贴着额角。内着素白中衣，领口整洁，外罩浅青宽袖外袍，袍身无多余纹样，腰带系得松而随意，腰间只挂一枚看似普通的玉牌，整体干净素淡，毫不张扬。足踏浅色布鞋。' },
            { name: '预设九：眉如远山', gender: '女', age: 20, personality: '内心长期处于一种低压的紧绷状态，对外界本能地保持戒备，难以轻易松弛。疑心重，不擅信任，内里敏感，但将这份敏感深埋，以冷漠作为外壳。', appearance: '眉如远山，眼神清冽如深潭，五官精致偏冷感，不施粉黛却自有风骨，薄唇常抿，鲜少笑颜。发以银环半束，余发披散于背，鬓边别一支白玉簪花。外披一件广袖银灰外氅，内着月白交领长裙，裙摆处以浅银丝线绣流云暗纹，腰间系细银腰封，缀淡蓝色流苏。袖口宽大飘逸，行走间衣袂翻飞如霜。足踏月白绣鞋，鞋面同样以银线点缀。随身携带一把素色折扇，扇面绘墨色寒梅，平日不用时插于腰间。' },
            { name: '预设十：圆眼大眸', gender: '女', age: 18, personality: '对大多数事提不起强烈的欲望，心态松散，少有执念。不是真的无所求，只是欲望的阈值偏低，容易满足于当下，缺乏向前的紧迫感。', appearance: '圆眼大眸，眼神灵动热烈，眼尾天生带一点上扬，笑起来极具感染力，脸颊健康红润，鼻梁略有雀斑。单侧辫子，刘海略乱，发间别一朵红色绒花装饰。上着朱红束腰短襦，下配明黄色阔腿练功裤，腰间系一条绣虎纹的宽腰带，充满野气。外出时会套一件宽松的橘红色短披风，随风飘扬极为张扬。足踏红底黑纹武靴，鞋尖微翘。手腕戴一只铃铛手环，走路必响，随身背一把略显粗笨的铁背剑。' },
            { name: '预设十一：柳叶眉', gender: '女', age: 21, personality: '思维缜密，凡事习惯提前预判，对人对事有清醒的功利意识。情绪稳定，极少冲动，内里有明确的目的性，但懂得将其妥善包裹。', appearance: '柳叶眉，眼神温柔带笑，眼角微微弯起，肤若凝脂，笑起来有两个浅浅梨涡，令人如沐春风。发挽成低髻，用浅绿色发带束起，鬓边别几朵白花。上着荷色交领上衣，下配嫩绿色长裙，裙摆宽大，走路间似荷叶随风。外罩一件薄如蝉翼的浅绿纱衣，腰间系绣莲纹细腰带，缀一枚碧玉佩。足踏绣莲花纹绣鞋，鞋面刺绣精致，手腕常戴一串绿玛瑙手串。' },
            { name: '预设十二：眉形细而微蹙', gender: '女', age: 23, personality: '天性中带着一种对自身魅力的自觉与从容，不刻意，却始终游刃有余。情绪流动自然，少有棱角，对世事抱一种懒散的接纳态度。', appearance: '眉形细而微蹙，眼神清冷带刺，眼型偏长，眼尾微挑，瞳色深沉，静静望人时有一种叫人不自在的锐利。鼻梁纤直，唇瓣偏薄，唇色浅淡，面部轮廓柔中带硬，气质疏离。发色深黑，绾成简单低髻以素色发带束紧，鬓边碎发不加收拾地散着。内着暗紫交领窄袖长衣，外披深靛色宽领外氅，腰间系细绳，不缀多余挂饰，偶有一枚黑玉吊坠垂于腰侧。足踏深色绣鞋，裙摆收窄。' },
            { name: '预设十三：眉形自然舒展', gender: '女', age: 19, personality: '外表呈现出的柔弱与内里的清醒之间存在刻意的落差。善于感知他人情绪并加以利用，本能地倾向于以弱势姿态换取主动权，自我保护意识极强。', appearance: '眉形自然舒展，眼神懒洋洋带着一点笑意，眼型圆而有神，眼尾微弯，瞳色浅棕，看人时总有种似认真又似走神的迷糊感。鼻梁小巧，唇形饱满，唇色自然粉润，面部轮廓圆润偏可爱。发色棕黑，发质柔顺，常常只是随手挽个松散的发髻便算了事，总有几缕发丝耷拉下来，懒得别好。内着杏色宽松中衣，外套柔黄广袖外袍，腰带系得不紧不松，挂饰时有时无，整体蓬松柔软。足踏软底平鞋，鞋面偶有褶皱也不在乎。' },
            { name: '预设十四：眉形弯而精致', gender: '女', age: 22, personality: '性情疏离，与外界保持天然的距离感，并不刻意为之，只是本能如此。内里有强烈的自我准则，对认定的事执着，不易被外力撼动，亦不在意旁人的看法。', appearance: '眉形弯而精致，眼神柔和带笑，眼型细长，眼尾上扬，瞳色明亮。鼻梁纤细挺直，唇形饱满，唇色偏桃红，笑起来梨涡浅现，面部轮廓精致柔美。发色乌黑带光泽，绾成精巧发髻，以镶珠发钗固定，垂下几缕卷发贴于颊侧，妆容得体清雅。内着浅白交领窄袖内衣，外罩桃粉广袖罗裙，腰间系绣花细腰封，配以流苏玉佩，整体娇而不俗。足踏绣花软底鞋，出入皆仪态端方。' },
            { name: '预设十五：眉形细弯如月', gender: '女', age: 23, personality: '情绪外放，感受力强，容易被外界点燃，对事物的投入快且直接。冲动先于理智，少有城府，内里单纯，有一股不计后果的蛮劲。', appearance: '眉形细弯如月，眉尾轻轻下扫，眼型杏而偏长，眼尾微微上挑，瞳色偏暖，眼波含情。鼻梁纤细微翘，唇瓣饱满圆润，唇色天然偏深粉，抿唇微笑时唇角漾出一点弧度，面部轮廓柔美，颧骨微高，整体艳而不俗。发色乌黑柔顺，以金钗绾成松散低髻，余发垂落肩侧，鬓边缀一朵深红绒花，压着几缕碎发。内着烟粉色斜襟窄袖长衣，外罩绛红广袖薄纱外氅，纱面隐约可见内里衣纹，腰间系细金腰封，坠以红玉流苏，行走间轻轻摇曳。足踏绣红梅纹软底绣鞋，步态轻盈，裙摆随行。' },
            { name: '预设十六：眉形细弯', gender: '女', age: 17, personality: '性情平和，少有强烈的情绪起伏，待人自然带着一种包容与体谅。内里柔韧，不张扬，不争锋，却有自己安静的坚持。', appearance: '眉形细弯，眉头天生略蹙，眼型圆而偏大，眼尾微垂，瞳色浅而清透，眼眶略红带着一种无声的楚楚可怜。鼻梁小巧微翘，鼻尖略圆，唇瓣圆润饱满，唇色浅粉，说话时唇角轻轻颤动，面部轮廓圆柔，肤色白腻，整体娇小柔弱，一眼望去叫人心生怜惜。发色柔软的深黑，绾成半松不紧的双鬟，以粉色发绳系住，总有几缕碎发散落额前颊侧。内着嫩白交领细棉内衣，外罩浅粉广袖长裙，裙面素净，腰间系一条细绒腰带，缀一枚小巧粉玉坠，整体柔软轻盈，毫无侵略性。足踏粉白绣鞋。' }
        ];

        // 灵根配置
        const spiritualRootTypes = ['五灵根', '三灵根', '双灵根', '单灵根', '变异灵根', '混沌灵根'];
        const normalElements = ['金', '木', '水', '火', '土'];
        const variantElements = ['雷', '冰', '风', '暗', '光'];

        // 出身背景配置
        const backgroundTypes = [
            { name: '凡人村落', desc: '普通人家，无修仙背景' },
            { name: '修仙世家', desc: '从小接触功法，初始悟性+5' },
            { name: '皇族后裔', desc: '天生贵胄，初始气运+5' },
            { name: '散修遗孤', desc: '独自求生，初始身法+5' },
            { name: '妖兽后裔', desc: '体质特殊，初始根骨+5' },
            { name: '天降异象', desc: '出生有异象，初始魅力+10' }
        ];

        // AI生成标记
        let aiPersonalityFirstTime = true;
        let aiAppearanceFirstTime = true;

        // 打开角色创建模态框
        function openCharacterCreation() {
            document.getElementById('characterCreationModal').classList.add('show');
            document.body.style.overflow = 'hidden';
        }

        // 关闭角色创建模态框
        function closeCharacterCreation() {
            document.getElementById('characterCreationModal').classList.remove('show');
            document.body.style.overflow = '';
        }

        // 随机生成灵根
        function generateRandomSpiritualRoot() {
            const rootType = spiritualRootTypes[Math.floor(Math.random() * spiritualRootTypes.length)];
            let elements = [];

            switch(rootType) {
                case '单灵根':
                    elements = [normalElements[Math.floor(Math.random() * normalElements.length)]];
                    break;
                case '双灵根':
                    elements = [...normalElements].sort(() => 0.5 - Math.random()).slice(0, 2);
                    break;
                case '三灵根':
                    elements = [...normalElements].sort(() => 0.5 - Math.random()).slice(0, 3);
                    break;
                case '五灵根':
                    elements = [...normalElements];
                    break;
                case '变异灵根':
                    const variantCount = Math.floor(Math.random() * 2) + 1;
                    const normalCount = Math.floor(Math.random() * 2) + 1;
                    elements = [...variantElements].sort(() => 0.5 - Math.random()).slice(0, variantCount);
                    elements.push(...[...normalElements].sort(() => 0.5 - Math.random()).slice(0, normalCount));
                    break;
                case '混沌灵根':
                    const allElements = [...normalElements, ...variantElements];
                    elements = [...allElements].sort(() => 0.5 - Math.random()).slice(0, Math.floor(Math.random() * 4) + 2);
                    break;
            }

            document.getElementById('spiritualRootType').value = rootType;
            document.getElementById('spiritualRootElements').value = elements.join('+');
            document.getElementById('rootTypeDisplay').textContent = rootType;
            document.getElementById('rootElementsDisplay').textContent = elements.join('、');
        }

        // 随机生成出身
        function generateRandomBackground() {
            const bg = backgroundTypes[Math.floor(Math.random() * backgroundTypes.length)];
            document.getElementById('charBackground').value = bg.name;
            document.getElementById('backgroundNameDisplay').textContent = bg.name;
            document.getElementById('backgroundDescDisplay').textContent = bg.desc;
        }

        // 随机生成性格
        function generateRandomPersonality() {
            const randomIndex = Math.floor(Math.random() * characterPresets.length);
            document.getElementById('charPersonality').value = characterPresets[randomIndex].personality;
        }

        // 随机生成外貌
        function generateRandomAppearance() {
            const gender = document.getElementById('charGender').value;
            const age = parseInt(document.getElementById('charAge').value);

            if (!gender) {
                alert('请先选择性别');
                return;
            }
            if (!age || age < 10 || age > 100) {
                alert('请先输入有效的年龄（10-100岁）');
                return;
            }

            let ageGroup;
            if (age <= 15) ageGroup = 'child';
            else if (age <= 25) ageGroup = 'youth';
            else if (age <= 40) ageGroup = 'adult';
            else if (age <= 60) ageGroup = 'middle';
            else ageGroup = 'elder';

            const matchingPresets = characterPresets.filter(preset => {
                let presetAgeGroup;
                if (preset.age <= 15) presetAgeGroup = 'child';
                else if (preset.age <= 25) presetAgeGroup = 'youth';
                else if (preset.age <= 40) presetAgeGroup = 'adult';
                else if (preset.age <= 60) presetAgeGroup = 'middle';
                else presetAgeGroup = 'elder';
                return preset.gender === gender && presetAgeGroup === ageGroup;
            });

            const presetsToUse = matchingPresets.length > 0 ? matchingPresets : characterPresets.filter(p => p.gender === gender);
            const randomIndex = Math.floor(Math.random() * presetsToUse.length);
            document.getElementById('charAppearance').value = presetsToUse[randomIndex].appearance;
        }

        // AI生成性格
        async function generateAIPersonality() {
            if (aiPersonalityFirstTime) {
                if (!confirm('使用AI生成性格将消耗token（约200-400 tokens）。是否继续？')) return;
                aiPersonalityFirstTime = false;
            }
            alert('AI生成功能需要配置API后使用');
        }

        // AI生成外貌
        async function generateAIAppearance() {
            if (aiAppearanceFirstTime) {
                if (!confirm('使用AI生成外貌将消耗token（约500-800 tokens）。是否继续？')) return;
                aiAppearanceFirstTime = false;
            }
            alert('AI生成功能需要配置API后使用');
        }

        // 表单提交处理函数
        async function handleCharacterFormSubmit(e) {
            e.preventDefault();
            
            const spiritualRootType = document.getElementById('spiritualRootType').value;
            const spiritualRootElements = document.getElementById('spiritualRootElements').value;
            const background = document.getElementById('charBackground').value;

            if (!spiritualRootType || !spiritualRootElements) {
                alert('请生成灵根');
                return;
            }
            if (!background) {
                alert('请生成出身背景');
                return;
            }

            const characterData = {
                name: document.getElementById('charName').value.trim(),
                gender: document.getElementById('charGender').value,
                age: parseInt(document.getElementById('charAge').value),
                personality: document.getElementById('charPersonality').value.trim(),
                appearance: document.getElementById('charAppearance').value.trim(),
                spiritual_root_type: spiritualRootType,
                spiritual_root_elements: spiritualRootElements,
                country: document.getElementById('charCountry').value,
                identity: document.getElementById('charIdentity').value,
                background: background,
                combat_power: 100
            };
            
            console.log('角色数据准备提交:', characterData);
            console.log('灵根类型:', spiritualRootType);
            console.log('灵根属性:', spiritualRootElements);

            // 使用 app.createCharacter 创建角色（会自动保存到 IndexedDB 并设置当前角色）
            let character;
            if (app && app.createCharacter) {
                character = await app.createCharacter(characterData);
                console.log('createCharacter返回:', character);
            } else {
                // 降级处理：直接保存到 localStorage
                localStorage.setItem('currentCharacter', JSON.stringify(characterData));
                character = characterData;
            }
            
            // 更新当前角色变量
            currentCharacter = character;
            console.log('设置currentCharacter:', currentCharacter);
            
            // 关闭模态框并刷新界面
            closeCharacterCreation();
            updateCharacterDisplay();
            
            alert(`角色「${characterData.name}」创建成功！`);
        }
        
        // 绑定表单提交事件（在DOM加载完成后）
        document.addEventListener('DOMContentLoaded', function() {
            const form = document.getElementById('characterForm');
            if (form) {
                form.addEventListener('submit', handleCharacterFormSubmit);
            }
        });

        // 更新角色显示
        function updateCharacterDisplay() {
            const character = JSON.parse(localStorage.getItem('currentCharacter') || 'null');
            if (character) {
                const elements = {
                    charNameDisplay: document.getElementById('charNameDisplay'),
                    charGenderDisplay: document.getElementById('charGenderDisplay'),
                    charAgeDisplay: document.getElementById('charAgeDisplay'),
                    charRealmDisplay: document.getElementById('charRealmDisplay'),
                    charRootDisplay: document.getElementById('charRootDisplay'),
                    charBackgroundDisplay: document.getElementById('charBackgroundDisplay'),
                    charCountryDisplay: document.getElementById('charCountryDisplay'),
                    charIdentityDisplay: document.getElementById('charIdentityDisplay')
                };

                if (elements.charNameDisplay) elements.charNameDisplay.textContent = character.name;
                if (elements.charGenderDisplay) elements.charGenderDisplay.textContent = character.gender;
                if (elements.charAgeDisplay) elements.charAgeDisplay.textContent = character.age + '岁';
                if (elements.charRealmDisplay) elements.charRealmDisplay.textContent = character.realm;
                if (elements.charRootDisplay) elements.charRootDisplay.textContent = `${character.spiritual_root_type}(${character.spiritual_root_elements})`;
                if (elements.charBackgroundDisplay) elements.charBackgroundDisplay.textContent = character.background;
                if (elements.charCountryDisplay) elements.charCountryDisplay.textContent = character.country;
                if (elements.charIdentityDisplay) elements.charIdentityDisplay.textContent = character.identity || '修仙者';
            }
        }
    </script>

    <!-- 角色创建模态框 -->
    <div class="character-creation-overlay" id="characterCreationModal">
        <div class="character-creation-modal">
            <div class="character-creation-header">
                <h2>爻</h2>
                <p>创建你的修仙角色</p>
                <button class="character-creation-close" onclick="closeCharacterCreation()" title="关闭">×</button>
            </div>
            
            <div class="character-creation-content">
                <form id="characterForm">
                    <!-- 第一行：角色名、性别、年龄 -->
                    <div class="character-creation-form-row">
                        <div class="form-group">
                            <label class="form-label">角色名<span class="required">*</span></label>
                            <input type="text" class="form-input" id="charName" placeholder="请输入角色名（2-20个字符）" maxlength="20" required>
                        </div>
                        <div class="form-group">
                            <label class="form-label">性别<span class="required">*</span></label>
                            <select class="form-select" id="charGender" required>
                                <option value="">请选择</option>
                                <option value="男">男</option>
                                <option value="女">女</option>
                            </select>
                        </div>
                    </div>

                    <!-- 年龄 -->
                    <div class="form-group">
                        <label class="form-label">年龄<span class="required">*</span></label>
                        <input type="number" class="form-input" id="charAge" placeholder="请输入年龄（10-100岁）" min="10" max="100" required>
                    </div>

                    <!-- 性格 -->
                    <div class="form-group">
                        <label class="form-label">性格<span class="required">*</span></label>
                        <textarea class="form-textarea" id="charPersonality" placeholder="描述角色的性格特点，如：清冷禁欲、凛然不可犯、外冷内热..." rows="2" required oninput="this.style.height='auto';this.style.height=this.scrollHeight+'px'"></textarea>
                        <div class="generate-buttons">
                            <button type="button" class="random-btn" onclick="generateRandomPersonality()">随机</button>
                            <button type="button" class="random-btn ai-btn" onclick="generateAIPersonality()">AI生成</button>
                        </div>
                    </div>

                    <!-- 外貌描述 -->
                    <div class="form-group">
                        <label class="form-label">外貌描述<span class="required">*</span></label>
                        <textarea class="form-textarea" id="charAppearance" placeholder="描述角色的外貌特征..." rows="3" required oninput="this.style.height='auto';this.style.height=this.scrollHeight+'px'"></textarea>
                        <div class="generate-buttons">
                            <button type="button" class="random-btn" onclick="generateRandomAppearance()">随机</button>
                            <button type="button" class="random-btn ai-btn" onclick="generateAIAppearance()">AI生成</button>
                        </div>
                    </div>

                    <!-- 灵根和出身背景并排 -->
                    <div class="character-creation-form-row">
                        <!-- 灵根 -->
                        <div class="form-group">
                            <div class="label-row">
                                <label class="form-label">灵根<span class="required">*</span></label>
                                <button type="button" class="random-btn dice-btn" onclick="generateRandomSpiritualRoot()" title="随机生成灵根">
                                    <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor">
                                        <path d="M3 3h18v18H3V3zm16 16V5H5v14h14zM7 7h4v4H7V7zm6 0h4v4h-4V7zm-6 6h4v4H7v-4zm6 0h4v4h-4v-4z"/>
                                    </svg>
                                </button>
                            </div>
                            <input type="hidden" id="spiritualRootType">
                            <input type="hidden" id="spiritualRootElements">
                            <div class="spiritual-root-display" id="spiritualRootDisplay">
                                <span class="root-type" id="rootTypeDisplay">点击骰子生成灵根</span>
                                <span class="root-elements" id="rootElementsDisplay"></span>
                            </div>
                        </div>

                        <!-- 出身背景 -->
                        <div class="form-group">
                            <div class="label-row">
                                <label class="form-label">出身背景<span class="required">*</span></label>
                                <button type="button" class="random-btn dice-btn" onclick="generateRandomBackground()" title="随机生成出身">
                                    <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor">
                                        <path d="M3 3h18v18H3V3zm16 16V5H5v14h14zM7 7h4v4H7V7zm6 0h4v4h-4V7zm-6 6h4v4H7v-4zm6 0h4v4h-4v-4z"/>
                                    </svg>
                                </button>
                            </div>
                            <input type="hidden" id="charBackground">
                            <div class="background-display" id="backgroundDisplay">
                                <span class="background-name" id="backgroundNameDisplay">点击骰子生成出身</span>
                                <span class="background-desc" id="backgroundDescDisplay"></span>
                            </div>
                        </div>
                    </div>

                    <!-- 出生国家 -->
                    <div class="form-group">
                        <label class="form-label">出生国家<span class="required">*</span></label>
                        <select id="charCountry" class="form-select" required>
                            <option value="">请选择国家</option>
                            <option value="玄北">玄北国（雪山之巅，凛冬不散）</option>
                            <option value="西刹">西刹国（迷雾森林，木系为基）</option>
                            <option value="东澜">东澜国（滨海之地，四季分明）</option>
                        </select>
                    </div>

                    <!-- 身份选择 -->
                    <div class="form-group">
                        <label class="form-label">身份<span class="required">*</span></label>
                        <select id="charIdentity" class="form-select" required>
                            <option value="">请选择身份</option>
                            <option value="修仙者">修仙者（可入仙门，接触修仙界）</option>
                            <!-- 后期解锁身份：
                            <option value="平民" disabled>平民百姓（人间烟火，不可入仙门）</option>
                            <option value="天神" disabled>天神下凡（需前置剧情解锁）</option>
                            <option value="鬼魂" disabled>鬼魂（需前置剧情解锁）</option>
                            <option value="妖族" disabled>妖族（需前置剧情解锁）</option>
                            -->
                        </select>
                        <small style="color: #8a8278; font-size: 11px; margin-top: 4px; display: block;">更多身份将在后续版本中开放</small>
                    </div>

                    <!-- 提交按钮 -->
                    <div class="submit-area">
                        <button type="submit" class="submit-btn">创建角色</button>
                    </div>
                </form>
            </div>
        </div>
    </div>
</body>
</html>
